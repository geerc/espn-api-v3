# ### EXPECTED STANDINGS
#
# #### TODO: Update to use the new Value Informed Power Rankings instead of just AllPlayWin%
#
# allplay_es = allplay.copy() # creat copy of all play to be used for expected standings
# allplay_es = allplay_es.set_index('team') # set the index to team for .loc
#
# # new dataframe for expected standings
# # ValuePowerRankings_ES = allplay_ps_val[['team','Weighted Avg']]
# # ValuePowerRankings_ES = ValuePowerRankings_ES.set_index('team')
#
# # move everything to positive
# # ValuePowerRankings_ES['Weighted Avg'] = ValuePowerRankings_ES['Weighted Avg'] + abs(ValuePowerRankings_ES['Weighted Avg'].min())
#
#
# allScheduleProb = [] # empty list to be filled with win probabilities for each teams schedule
# sos = [] # strength of schedule list
#
# for team in teams:
#     teamAP = allplay_es['AllPlayWin%'].loc[team.team_name] # Get each teams current All Play Win Percentage
#     # teamPS = ValuePowerRankings_ES['Weighted Avg'].loc[team.teamName] # Get each teams current All Play Win Percentage
#
#     scheduleOBJ = team.schedule # get list of team objects
#     scheduleProb = [] # tempory list to fill in inner for loop
#     teamSOS = 0 # initialize to 0 for each team
#     for opp in scheduleOBJ:
#         # oppAP = allplay_es['AllPlayWin%'].loc[opp.teamName]
#         # prob = teamAP / (oppAP + teamAP)
#
#         oppPS = allplay_es.loc[opp.team_name]
#         prob = teamAP / (oppPS + teamAP)
#
#         teamSOS += oppPS
#         scheduleProb.append(prob)
#         # for values in key:
#         #      schedule.append(item.teamName)
#     allScheduleProb.append(scheduleProb) # append each team
#     addToSOS = [team.team_name, teamSOS]
#     sos.append(addToSOS) # append each team's SOS
# print(allScheduleProb)
#
# # convert to pandas dataframes
# allScheduleProb = pd.DataFrame(allScheduleProb)
# sos = pd.DataFrame(sos).round(2)
#
# sos = sos.iloc[:,0:2] # remove empty end column
# sos = sos.set_axis(['Team', 'SOS'], axis=1) # set column names
#
# probSched = pd.DataFrame(team_names, columns = ['Team'])
# probSched = probSched.join(allScheduleProb)
#
# weeksLeft = week - 15
# probSchedLeft = probSched[probSched.columns[weeksLeft:]] # create dataframe of the prob schedules for weeks left to play
#
# projectedStandings = pd.DataFrame(probSched['Team'].to_numpy(), columns=['Team']) # start projectedStandings with just team names
#
# currentWins = []
# currentLosses = []
# # add current wins and losses to empty lists to be added to projectedStandings
# for team in teams:
#     currentWins = np.append(currentWins, team.wins)
#     currentLosses = np.append(currentLosses, team.losses)
#
# projectedStandings['CurrentWins'] = currentWins
# projectedStandings['CurrentLosses'] = currentLosses
#
# # sum up the probabilties to get proj wins and losses
# projectedStandings['ForcastedWins'] = probSched.iloc[:, weeksLeft-2:-2].sum(axis=1).round(2)
# projectedStandings['ForcastedLosses'] = abs(weeksLeft) - projectedStandings['ForcastedWins'].round(2)
#
# # add projected and current wins to total projection
# totalWinProj = projectedStandings['CurrentWins'] + projectedStandings['ForcastedWins']
# totalLossProj = projectedStandings['CurrentLosses'] + projectedStandings['ForcastedLosses']
#
# # insert total win and loss projections
# projectedStandings.insert(loc=1, column='TotalProjWins', value=totalWinProj)
# projectedStandings.insert(loc=2, column='TotalProjLoss', value=totalLossProj)
#
# # sort and reset index
# projectedStandings = projectedStandings.sort_values(by='TotalProjWins', ascending=False)
# projectedStandings = projectedStandings.reset_index(drop=True)
#
# projectedStandings_prnt = projectedStandings[['Team','TotalProjWins','TotalProjLoss']]
#
# # if week >= 9:
# #     # Merge in SOS
# #     projectedStandings_prnt = projectedStandings_prnt.merge(sos, on='Team')

## MONTE CARLO PLAYOFF PROBABILIIES


#number of random season's to simulate
simulations = 1000000
#weeks in the regular season
league_weeks = 15
#number of teams to playoffs
teams_to_play_off = 4

#team_names:: list of team names. list order is used to
#index home_teams and away_teams

#home_teams, away_teams: list of remaining matchups in the regular season.
#Indexes are based on order from team_names

#current_wins: Integer value represents each team's win count.
#The decimal is used to further order teams based on points for eg 644.8 points would be 0.006448.
#Order needs to be the same as team_names

# teams already added to list in code above
# ['Pat'[1], 'Trevor'[2], 'Billy'[3], 'Jack'[4], 'Travis'[5], 'Lucas'[6], 'Cade'[7], 'Christian'[8]]

# Remaining schedule (week 5 and on)
home_teams = [8,5,4,6,3,1,7,2,1,7,3,2,6,3,2,4,8,2,1,4,8,3,1,6,8,5,4,6,7,3,2,1,8,5,4,1,1,3,2,7,2,3,7,1]
away_teams = [7,1,2,3,8,6,4,5,8,5,4,6,8,1,7,5,5,3,7,6,4,7,2,5,2,3,1,7,8,6,4,5,3,2,7,6,8,4,6,5,8,4,6,5]

# only update current wins at week 5
# don't need to do below, taken care of in for loop
# current_wins = [2.010742,3.011697,7.013179,2.010177,6.011863,1.010001,6.012642,5.011502]
current_wins = []
for team in teams_list:
    wins = team.wins
    scores = team.scores
    PF = sum(scores.values())
    PF = round(PF, 2)
    PF = PF/100000
    current_wins.append(wins + PF)

###ONLY CONFIGURE THE VALUES ABOVE

if week >= 5:
    teams = [int(x) for x in range(1,len(team_names)+1)]
    weeks_played = (league_weeks)-((len(home_teams))/(len(teams)/2))


    last_playoff_wins = [0] * (league_weeks)
    first_playoff_miss = [0] * (league_weeks)

    import datetime

    begin = datetime.datetime.now()
    import random


    league_size = len(teams)


    games_per_week = int(league_size/2)
    weeks_to_play = int(league_weeks-weeks_played)
    total_games = int(league_weeks * games_per_week)
    games_left = int(weeks_to_play * games_per_week)

    stats_teams = [0] * (league_size)


    play_off_matrix = [[0 for x in range(teams_to_play_off)] for x in range(league_size)]

    pad = int(games_left)

    avg_wins = [0.0] * teams_to_play_off


    for sims in progressbar.progressbar(range(1,simulations+1)):
        #create random binary array representing a single season's results
        val = [int(random.getrandbits(1)) for x in range(1,(games_left+1))]

        empty_teams = [0.0] * league_size

        i = 0
        #assign wins based on 1 or 0 to home or away team
        for x in val:
            if (val[i] == 1):
                empty_teams[home_teams[i]-1] = empty_teams[home_teams[i]-1]+1
            else:
                empty_teams[away_teams[i]-1] = empty_teams[away_teams[i]-1]+1
            i=i+1

        #add the current wins to the rest of season's results
        empty_teams = [sum(x) for x in zip(empty_teams,current_wins)]

        #sort the teams
        sorted_teams = sorted(empty_teams)



        last_playoff_wins[int(round(sorted_teams[(league_size-teams_to_play_off)],0))-1] = last_playoff_wins[int(round(sorted_teams[(league_size-teams_to_play_off)],0))-1] + 1
        first_playoff_miss[int(round(sorted_teams[league_size-(teams_to_play_off+1)],0))-1] = first_playoff_miss[int(round(sorted_teams[league_size-(teams_to_play_off+1)],0))-1] + 1



        #pick the teams making the playoffs
        for x in range(1,teams_to_play_off+1):
            stats_teams[empty_teams.index(sorted_teams[league_size-x])] = stats_teams[empty_teams.index(sorted_teams[league_size-x])] + 1
            avg_wins[x-1] = avg_wins[x-1] + round(sorted_teams[league_size-x],0)
            play_off_matrix[empty_teams.index(sorted_teams[league_size-x])][x-1] = play_off_matrix[empty_teams.index(sorted_teams[league_size-x])][x-1] + 1

    projections = []

    playSpots = []

    for x in range(1,len(stats_teams)+1):
        vals = ''
        for y in range(1,teams_to_play_off+1):
            vals = vals +'\t'+str(round((play_off_matrix[x-1][y-1])/simulations*100.0,2))

            playSpots.append(round((play_off_matrix[x-1][y-1])/simulations*100.0,2))

        playProb = round((stats_teams[x-1])/simulations*100.0,2)
        playSpots.insert(0, playProb)
        # print("Vals: ", playSpots)
        projections.append(playSpots)
        playSpots = []
        # print(team_names[x-1]+'\t'+str(round((stats_teams[x-1])/simulations*100.0,2))+vals)

    projections = pd.DataFrame(projections)
    projections.insert(loc=0, column='Team', value=team_names)
    projections = projections.set_axis(['Team', 'Playoffs', '1st Seed', '2nd Seed', '3rd Seed', '4th Seed'], axis=1, inplace=False)
    projections = projections.sort_values(by=['Playoffs','1st Seed', '2nd Seed', '3rd Seed', '4th Seed'], ascending=False)
    # projections[['1st Seed','2nd Seed','3rd Seed', '4th Seed']] = projections[['1st Seed','2nd Seed','3rd Seed', '4th Seed']].astype(str) + "%"
    projections.index = np.arange(1, len(projections) + 1)

    median = projections['Playoffs'].median()

    # bold only the playoff teams
    for index, row in projections.iterrows():
        if row['Playoffs'] > median:
            projections.loc[index, 'Team'] = '**' + str(row['Team']) + '**'
            projections.loc[index, 'Playoffs'] = '**' + str(row['Playoffs']) + '%**'
            projections.loc[index, '1st Seed'] = '**' + str(row['1st Seed']) + '%**'
            projections.loc[index, '2nd Seed'] = '**' + str(row['2nd Seed']) + '%**'
            projections.loc[index, '3rd Seed'] = '**' + str(row['3rd Seed']) + '%**'
            projections.loc[index, '4th Seed'] = '**' + str(row['4th Seed']) + '%**'
        else:
            projections.loc[index, 'Playoffs'] = str(row['Playoffs']) + '%'
            projections.loc[index, '1st Seed'] = str(row['1st Seed']) + '%'
            projections.loc[index, '2nd Seed'] = str(row['2nd Seed']) + '%'
            projections.loc[index, '3rd Seed'] = str(row['3rd Seed']) + '%'
            projections.loc[index, '4th Seed'] = str(row['4th Seed']) + '%'

    print('')

    # print('Average # of wins for playoff spot')
    # for x in range(1,teams_to_play_off+1):
    #     print(str(x)+'\t'+str(round((avg_wins[x-1])/simulations,2)))


    delta = datetime.datetime.now() - begin

    # print('')
    # print('Histrogram of wins required for final playoff spot')
    # for x in range(1,len(last_playoff_wins)+1):
    #     print(str(x)+'\t'+str(round((last_playoff_wins[x-1])/(simulations*1.0)*100,3))+'\t'+str(round((first_playoff_miss[x-1])/(simulations*1.0)*100,3)))


    print('\n{0:,}'.format(simulations) +" Simulations ran in "+str(delta))

# Set index for printing tables to start at 1
allplay.index = np.arange(1, len(allplay) + 1)
allplay_ps.index = np.arange(1, len(allplay_ps) + 1)
if week >5:
    projections.index = np.arange(1, len(projections) + 1)
team_scores_prt.index = np.arange(1, len(team_scores_prt) + 1)
projectedStandings_prnt.index = np.arange(1, len(projectedStandings_prnt) + 1)
Value_Power_Rankings_print.index = np.arange(1, len(Value_Power_Rankings) + 1)
