Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>'''\nTODO:\n1. After week 1 check that expected standings are lining up teams correctly when adding back to dataframe after simulation\n2. Update player values to pull from KTC\n3. Use player values to inform AI summary\n4. Create CRON job to run automatically\n5. Update args to default to current week if not specified\n'''\nfrom langchain_core.runnables import RunnableSequence\n\nimport pandas as pd\nfrom tabulate import tabulate as table\nimport sys\nimport argparse\nfrom espn_api.football import League\nfrom datetime import datetime\nimport re\nimport json\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain_openai import ChatOpenAI\nimport os\nfrom dotenv import load_dotenv\nfrom doritostats import luck_index\nimport time\nimport progressbar\nimport numpy as np\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"week\", help='Get week of the NFL season to run rankings for')\nargs = parser.parse_args()\nweek = int(args.week)\n\n# Define dates/year\nyear = datetime.now().year\nmonth =  datetime.now().month\nday = datetime.now().day\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Get login credentials for leagues\nleague_id = os.getenv('league_id')\nswid = os.getenv('swid')\nespn_s2 = os.getenv('espn_s2')\napi_key= os.getenv('OPEN_AI_KEY')\n\nleague = League(league_id, year, espn_s2, swid)\nprint(league, \"\\n\")\n\n# Create list of teams\nteams = league.teams\n\n# Create list of team names\nteam_names = [team_obj.team_name for team_obj in league.teams]\n\n\ndef gen_power_rankings():\n    power_rankings = league.power_rankings(week=week)\n\n    # Extract team names\n    extracted_team_names = [(record, re.sub(r'Team\\((.*?)\\)', r'\\1', str(team))) #convert team object to string\n        for record, team in power_rankings]\n\n    # Convert to Dataframe\n    power_rankings = pd.DataFrame(extracted_team_names, columns=['Power Score','Team'])\n\n\n    # Switch Score and Team Name cols\n    power_rankings_df = power_rankings.reindex(columns=['Team', 'Power Score'])\n\n    if week > 1:\n        # Generate last weeks' power rankings for comparison\n        prev_power_rankings = league.power_rankings(week=week-1)\n\n        # Extract team names\n        extracted_team_names = [(record, re.sub(r'Team\\((.*?)\\)', r'\\1', str(team)))  # convert team object to string\n                                for record, team in prev_power_rankings]\n\n        # Convert to Dataframe\n        prev_power_rankings_df = pd.DataFrame(extracted_team_names, columns=['Power Score', 'Team'])\n\n        # Switch Score and Team Name cols\n        prev_power_rankings_df = prev_power_rankings_df.reindex(columns=['Team', 'Power Score'])\n\n        diffs = []\n        emojis = []\n\n        print('This week: \\n', power_rankings_df)\n        print('Last week: \\n', prev_power_rankings_df)\n\n        for team in league.teams:\n            # print(team)\n            tw_rank = power_rankings_df[power_rankings_df['Team'] == team.team_name].index.values  # get this week's rank\n            # print(f'{team.team_name} rank this week: {tw_rank}')\n            lw_rank = prev_power_rankings_df[prev_power_rankings_df['Team'] == team.team_name].index.values  # get last weeks' rank\n            # print(f'{team.team_name} rank last week: {lw_rank}')\n            diff = lw_rank - tw_rank  # find the difference between last week to this week\n            # print(f'{team.team_name} weekly change: {diff}')\n            diff = int(diff.item())  # turn into list to iterate over\n            diffs.append(diff)  # append to the list\n\n        # iterate over diffs list and edit values to include up/down arrow emoji and the number of spots the team moved\n        for item in diffs:\n            if item > 0:\n                emojis.append(\"**<span style=\\\"color: green;\\\">⬆\uFE0F \" + str(abs(item)) + \" </span>**\")\n            elif item < 0:\n                emojis.append(\"**<span style=\\\"color: red;\\\">⬇\uFE0F \" + str(abs(item)) + \" </span>**\")\n            elif item == 0:\n                emojis.append(\"\")  # adds a index of nothing for teams that didn't move\n\n        power_rankings_df.insert(loc=1, column='Weekly Change', value=emojis)  # insert the weekly change column\n\n    # Set index to start at 1\n    power_rankings_df = power_rankings_df.set_axis(range(1, len(power_rankings_df) + 1))\n\n    return power_rankings_df\n\ndef gen_playoff_prob():\n    # Proj wins and losses for rest of season\n\n    # MONTE CARLO PLAYOFF PROBABILITIES\n    print('\\nGenerating Monte Carlo Playoff Probabilities...')\n    # number of random season's to simulate\n    simulations = 100000\n    # weeks in the regular season\n    league_weeks = 15\n    # number of teams to playoffs\n    teams_to_play_off = 4\n\n    # team_names:: list of team names. list order is used to\n    # index home_teams and away_teams\n\n    # home_teams, away_teams: list of remaining matchups in the regular season.\n    # Indexes are based on order from team_names\n\n    # current_wins: Integer value represents each team's win count.\n    # The decimal is used to further order teams based on points for eg 644.8 points would be 0.006448.\n    # Order needs to be the same as team_names\n\n    # Create dictionary of teams and id number to be fed to monte carlo simulations\n    # ['Pat'[1], 'Trevor'[2], 'Billy'[3], 'Jack'[4], 'Travis'[5], 'Lucas'[6], 'Cade'[7], 'Christian'[8]]\n    team_dictionary = {'Red Zone  Rockets':1, 'Final Deztination':2, 'Game of  Jones':3, 'Comeback Cardinals':4, 'OC Gang':5, 'Hurts Donit':6, 'Shippin Up To Austin':7, 'Team Ger':8}\n\n    # Initialize empty lists to store the names of home and away teams for each week\n    home_team_names = []\n    away_team_names = []\n\n    # Loop through each week from the current week until the last week of the season\n    for this_week in range(week, 16):\n        # Create emtpy sets to populate with each weeks home and away teams\n        week_home_teams = set()\n        week_away_teams = set()\n\n        # Retrieve the scoreboard for the current week, which contains matchups\n        week_scoreboard = league.scoreboard(this_week)\n\n        # Iterate through each matchup in the scoreboard for the week\n        for matchup in week_scoreboard:\n            # Add the home and away teams' names to the set of home/away teams\n            week_home_teams.add(matchup.home_team.team_name)\n            week_away_teams.add(matchup.away_team.team_name)\n\n        # Append the set of home teams for this week to the list of home team names\n        home_team_names.append(week_home_teams)\n\n        # Append the set of away teams for this week to the list of away team names\n        away_team_names.append(week_away_teams)\n\n    # Flatten the list of sets and replacing team names with their IDs.\n    # Give us a list in order of each weeks home and away teams for the rest of the season\n    home_teams = [team_dictionary[team.strip()] for teams_set in home_team_names for team in teams_set]\n    away_teams = [team_dictionary[team.strip()] for teams_set in away_team_names for team in teams_set]\n\n    # don't need to do below, taken care of in for loop. Format s wins.totalPointsScored as decimal to 6 places\n    # current_wins = [2.010742,3.011697,7.013179,2.010177,6.011863,1.010001,6.012642,5.011502]\n    current_wins = []\n    for team in league.teams:\n        wins = team.wins\n        scores = team.scores\n        total_points_scored = round(sum(scores), 2) / 100000\n        current_wins.append(wins + total_points_scored)\n\n    ###ONLY CONFIGURE THE VALUES ABOVE\n\n    teams = [int(x) for x in range(1, len(league.teams) + 1)]\n    weeks_played = (league_weeks) - ((len(home_teams)) / (len(teams) / 2))\n\n    last_playoff_wins = [0] * (league_weeks)\n    first_playoff_miss = [0] * (league_weeks)\n\n    import datetime\n\n    begin = datetime.datetime.now()\n    import random\n\n    league_size = len(teams)\n\n    games_per_week = int(league_size / 2)\n    weeks_to_play = int(league_weeks - weeks_played)\n    total_games = int(league_weeks * games_per_week)\n    games_left = int(weeks_to_play * games_per_week)\n\n    stats_teams = [0] * (league_size)\n\n    play_off_matrix = [[0 for x in range(teams_to_play_off)] for x in range(league_size)]\n\n    pad = int(games_left)\n\n    avg_wins = [0.0] * teams_to_play_off\n\n    for sims in progressbar.progressbar(range(1, simulations + 1)):\n        # create random binary array representing a single season's results\n        val = [int(random.getrandbits(1)) for x in range(1, (games_left + 1))]\n\n        empty_teams = [0.0] * league_size\n\n        i = 0\n        # assign wins based on 1 or 0 to home or away team\n        for x in val:\n            if (val[i] == 1):\n                empty_teams[home_teams[i] - 1] = empty_teams[home_teams[i] - 1] + 1\n            else:\n                empty_teams[away_teams[i] - 1] = empty_teams[away_teams[i] - 1] + 1\n            i = i + 1\n\n        # add the current wins to the rest of season's results\n        empty_teams = [sum(x) for x in zip(empty_teams, current_wins)]\n\n        # sort the teams\n        sorted_teams = sorted(empty_teams)\n\n        last_playoff_wins[int(round(sorted_teams[(league_size - teams_to_play_off)], 0)) - 1] = last_playoff_wins[int(round(sorted_teams[(league_size - teams_to_play_off)],0)) - 1] + 1\n        first_playoff_miss[int(round(sorted_teams[league_size - (teams_to_play_off + 1)], 0)) - 1] = \\\n        first_playoff_miss[int(round(sorted_teams[league_size - (teams_to_play_off + 1)], 0)) - 1] + 1\n\n        # pick the teams making the playoffs\n        for x in range(1, teams_to_play_off + 1):\n            stats_teams[empty_teams.index(sorted_teams[league_size - x])] = stats_teams[empty_teams.index(\n                sorted_teams[league_size - x])] + 1\n            avg_wins[x - 1] = avg_wins[x - 1] + round(sorted_teams[league_size - x], 0)\n            play_off_matrix[empty_teams.index(sorted_teams[league_size - x])][x - 1] = \\\n            play_off_matrix[empty_teams.index(sorted_teams[league_size - x])][x - 1] + 1\n\n    projections = []\n\n    playSpots = []\n\n    for x in range(1, len(stats_teams) + 1):\n        vals = ''\n        for y in range(1, teams_to_play_off + 1):\n            vals = vals + '\\t' + str(round((play_off_matrix[x - 1][y - 1]) / simulations * 100.0, 2))\n\n            playSpots.append(round((play_off_matrix[x - 1][y - 1]) / simulations * 100.0, 2))\n\n        playProb = round((stats_teams[x - 1]) / simulations * 100.0, 2)\n        playSpots.insert(0, playProb)\n        # print(\"Vals: \", playSpots)\n        projections.append(playSpots)\n        playSpots = []\n        # print(team_names[x-1]+'\\t'+str(round((stats_teams[x-1])/simulations*100.0,2))+vals)\n    # print(f'Pre dataframe projections\\n{projections}')\n    # Convert projections to Pandas Dataframe\n    projections = pd.DataFrame(projections)\n\n    # Insert Team Names to DataFrame\n    projections.insert(loc=0, column='Team', value=team_names)\n    projections = projections.set_axis(['Team', 'Playoffs', '1st Seed', '2nd Seed', '3rd Seed', '4th Seed'], axis=1)\n    projections = projections.sort_values(by=['Playoffs', '1st Seed', '2nd Seed', '3rd Seed', '4th Seed'], ascending=False)\n    # projections[['1st Seed','2nd Seed','3rd Seed', '4th Seed']] = projections[['1st Seed','2nd Seed','3rd Seed', '4th Seed']].astype(str) + \"%\"\n    projections.index = np.arange(1, len(projections) + 1)\n\n    median = projections['Playoffs'].median()\n\n    # bold only the playoff teams\n    for index, row in projections.iterrows():\n        if row['Playoffs'] > median:\n            projections.loc[index, 'Team'] = '**' + str(row['Team']) + '**'\n            projections.loc[index, 'Playoffs'] = '**' + str(row['Playoffs']) + '%**'\n            projections.loc[index, '1st Seed'] = '**' + str(row['1st Seed']) + '%**'\n            projections.loc[index, '2nd Seed'] = '**' + str(row['2nd Seed']) + '%**'\n            projections.loc[index, '3rd Seed'] = '**' + str(row['3rd Seed']) + '%**'\n            projections.loc[index, '4th Seed'] = '**' + str(row['4th Seed']) + '%**'\n        else:\n            projections.loc[index, 'Playoffs'] = str(row['Playoffs']) + '%'\n            projections.loc[index, '1st Seed'] = str(row['1st Seed']) + '%'\n            projections.loc[index, '2nd Seed'] = str(row['2nd Seed']) + '%'\n            projections.loc[index, '3rd Seed'] = str(row['3rd Seed']) + '%'\n            projections.loc[index, '4th Seed'] = str(row['4th Seed']) + '%'\n\n    print('')\n\n    # print('Average # of wins for playoff spot')\n    # for x in range(1,teams_to_play_off+1):\n    #     print(str(x)+'\\t'+str(round((avg_wins[x-1])/simulations,2)))\n\n    delta = datetime.datetime.now() - begin\n\n    # print('')\n    # print('Histrogram of wins required for final playoff spot')\n    # for x in range(1,len(last_playoff_wins)+1):\n    #     print(str(x)+'\\t'+str(round((last_playoff_wins[x-1])/(simulations*1.0)*100,3))+'\\t'+str(round((first_playoff_miss[x-1])/(simulations*1.0)*100,3)))\n\n    print('\\n{0:,}'.format(simulations) + \" Simulations ran in \" + str(delta))\n    print('\\nProjections:\\n', projections)\n\n    return projections\n\n\ndef gen_ai_summary():\n    print(\"\\n\\tRetrieving and processing matchups...\")\n\n    # Retrieve all matchups for the given week\n    matchups = league.box_scores(week=week)\n\n    # Extract box score data\n    box_scores_data = []\n\n    for matchup in matchups:\n        matchup_data = {\n            \"home_team\": matchup.home_team.team_name,\n            \"home_score\": matchup.home_score,\n            \"home_projected\": matchup.home_projected,\n            \"away_team\": matchup.away_team.team_name,\n            \"away_score\": matchup.away_score,\n            \"away_projected\": matchup.away_projected,\n            \"home_players\": [\n                {\n                    \"player_name\": player.name,\n                    \"slot_position\": player.slot_position,\n                    \"position\": player.position,\n                    \"points\": player.points,\n                    \"projected_points\": player.projected_points\n                } for player in matchup.home_lineup\n            ],\n            \"away_players\": [\n                {\n                    \"player_name\": player.name,\n                    \"position\": player.position,\n                    \"slot_position\": player.slot_position,\n                    \"points\": player.points,\n                    \"projected_points\": player.projected_points\n                } for player in matchup.away_lineup\n            ]\n        }\n        box_scores_data.append(matchup_data)\n\n    # Convert to JSON format\n    box_scores_json = json.dumps(box_scores_data, indent=4)\n\n    print(\"\\n\\tGenerating summary with LLM...\")\n\n    # Sample JSON data (replace with your actual JSON data)\n    # json_data = box_scores_json\n\n    # Setting up OpenAI model\n    llm = ChatOpenAI(model_name=\"gpt-4o-mini\", temperature=0, openai_api_key=api_key)\n\n    # Define the prompt template for generating a newspaper-like summary\n    prompt_template = PromptTemplate(\n        input_variables=[\"box_scores_json\"],\n        template=\"\"\"\n        Write a newspaper-style summary of the fantasy football matchups based on the following JSON data:\n\n        {box_scores_json}\n            \n        The summary should include:\n        - The names of the teams\n        - The projected scores for each team\n        - Key players and their projected points\n        - Any notable points or highlights\n\n        Write in a formal, engaging newspaper tone.\n        \"\"\"\n    )\n\n    # Initialize the LLMChain with the Llama model and prompt template\n    llm_chain = RunnableSequence(\n        prompt_template | llm\n    )\n\n    # Generate the newspaper-like summary\n    result = llm_chain.invoke(input=box_scores_json)\n\n    # return the result\n    return result.content\n\n# Generate Power Rankings\nprint('\\nGenerating Power Rankings...')\nrankings = gen_power_rankings()\n\n# Generate Expected Standings\n\n\n# Generate Playoff Probability (if week 5 or later) and append to expected standings\nif week > 5:\n    playoff_prob = gen_playoff_prob()\n\n# Generate Luck Index\nprint('\\nGenerating Luck Index...')\nbar_luck_index = progressbar.ProgressBar(max_value=len(teams))\n\nseason_luck_index = []\nluck_index_value = 0\nfor i, team in enumerate(teams):\n    team_name = team.team_name\n    for luck_week in range(1, week+1):\n        luck_index_value += luck_index.get_weekly_luck_index(league, team, luck_week)\n\n    # append team's season long luck index to the list\n    season_luck_index.append([team.team_name, luck_index_value])\n\n    # reset luck index value\n    luck_index_value = 0\n\n    # Update the progress bar\n    bar_luck_index.update(i + 1)\n\n# convert season long luck index list to pandas dataframe, sort by 'Luck Index', and set index to start at 1\nseason_luck_index = pd.DataFrame(season_luck_index, columns=['Team','Luck Index'])\nseason_luck_index.sort_values(by='Luck Index', ascending=False, inplace=True, ignore_index=True)\nseason_luck_index = season_luck_index.set_axis(range(1, len(season_luck_index)+1))\n\n\n# Generate AI Summary\nprint('\\n\\nGenerating AI Summary...')\nsummary = gen_ai_summary()\n\n# Print everything\nprint('\\nWriting to markdown file...')\n# open text file\nfilepath = f\"/Users/christiangeer/Fantasy_Sports/football/power_rankings/jtown-dynasty/content/blog/Week{week}{year}PowerRankings.md\"\nsys.stdout = open(filepath, \"w\")\n\n# for the markdown files in blog\nprint(\"---\")\nprint(\"title: Week\", str(week), year, \"Report\")\nprint(\"date: \",datetime.now().date())\nprint(f\"image: /images/{year}week{week}.jpg\")\nprint(\"draft: true\")\nprint(\"---\")\n\nprint(\"<!-- excerpt -->\")\n\nprint(\"\\n# POWER RANKINGS\\n\")\n# Value un-informed\nprint(table(rankings, headers='keys', tablefmt='pipe', numalign='center')) # have to manually center all play % because its not a number\n\n# print(table(Value_Power_Rankings_print, headers='keys',tablefmt='pipe', numalign='center')) # have to manually center all play % and weekly change because not an int\n\nprint('\\n## Summary:\\n')\nprint(summary)\n\n# print(\"\\n# EXPECTED STANDINGS (as of week \", week, \")\")\n# league.printExpectedStandings(week)\n# print(table(projectedStandings_prnt, headers='keys', tablefmt='pipe', numalign='center'))\n\nif week >= 5:\n    print(f\"\\n## PLAYOFF PROBABILITIES (as of week {week}\")\n    print(table(playoff_prob, headers='keys', tablefmt='pipe', numalign='center'))\n\nprint(\"\\n## LUCK INDEX\")\nprint(table(season_luck_index, headers='keys', tablefmt='pipe', numalign='center'))\n\n# print(\"\\n WEEK \", week, \" ALL PLAY STANDINGS (SORT BY WINS)\")\n# print(table(allplay, headers='keys', tablefmt='github', numalign='decimal'))\n\n# print(\"\\n WEEK \", week, \" POWER SCORE (CALC W/ LEAGUE AVERAGE SCORE)\")\n# print(table(team_scores_prt, headers='keys', tablefmt='github', numalign='decimal'))\n\n# Close file and restore standard output\nsys.stdout.close()\nsys.stdout = sys.__stdout__\n\nprint('\\nDone!\\n')\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 10d0f58e8729dab342a2c293c36b7a38a40f48c5)
+++ b/main.py	(date 1726002812254)
@@ -1,29 +1,35 @@
 '''
 TODO:
-1. After week 1 check that expected standings are lining up teams correctly when adding back to dataframe after simulation
-2. Update player values to pull from KTC
-3. Use player values to inform AI summary
-4. Create CRON job to run automatically
-5. Update args to default to current week if not specified
+1. Give LLM more/better information
+    1. Give/instruct to browse for news articles?
 '''
-from langchain_core.runnables import RunnableSequence
+
+import playerID
+from authorize import Authorize
+from team import Team
+from player import Player
+from utils.building_utils import getUrl
+from itertools import chain
 
 import pandas as pd
+import numpy as np
+import requests
+import math
 from tabulate import tabulate as table
+import os
 import sys
 import argparse
+import progressbar
 from espn_api.football import League
 from datetime import datetime
 import re
 import json
-from langchain_core.prompts import PromptTemplate
+import openai
+from langchain import LLMChain, PromptTemplate
 from langchain_openai import ChatOpenAI
+from utils.printing_utils import printPowerRankings
 import os
 from dotenv import load_dotenv
-from doritostats import luck_index
-import time
-import progressbar
-import numpy as np
 
 parser = argparse.ArgumentParser()
 parser.add_argument("week", help='Get week of the NFL season to run rankings for')
@@ -42,18 +48,11 @@
 league_id = os.getenv('league_id')
 swid = os.getenv('swid')
 espn_s2 = os.getenv('espn_s2')
-api_key= os.getenv('OPEN_AI_KEY')
+api_key= os.getenv('OPEN_API_KEY')
 
 league = League(league_id, year, espn_s2, swid)
 print(league, "\n")
 
-# Create list of teams
-teams = league.teams
-
-# Create list of team names
-team_names = [team_obj.team_name for team_obj in league.teams]
-
-
 def gen_power_rankings():
     power_rankings = league.power_rankings(week=week)
 
@@ -66,249 +65,11 @@
 
 
     # Switch Score and Team Name cols
-    power_rankings_df = power_rankings.reindex(columns=['Team', 'Power Score'])
-
-    if week > 1:
-        # Generate last weeks' power rankings for comparison
-        prev_power_rankings = league.power_rankings(week=week-1)
-
-        # Extract team names
-        extracted_team_names = [(record, re.sub(r'Team\((.*?)\)', r'\1', str(team)))  # convert team object to string
-                                for record, team in prev_power_rankings]
-
-        # Convert to Dataframe
-        prev_power_rankings_df = pd.DataFrame(extracted_team_names, columns=['Power Score', 'Team'])
-
-        # Switch Score and Team Name cols
-        prev_power_rankings_df = prev_power_rankings_df.reindex(columns=['Team', 'Power Score'])
-
-        diffs = []
-        emojis = []
-
-        print('This week: \n', power_rankings_df)
-        print('Last week: \n', prev_power_rankings_df)
-
-        for team in league.teams:
-            # print(team)
-            tw_rank = power_rankings_df[power_rankings_df['Team'] == team.team_name].index.values  # get this week's rank
-            # print(f'{team.team_name} rank this week: {tw_rank}')
-            lw_rank = prev_power_rankings_df[prev_power_rankings_df['Team'] == team.team_name].index.values  # get last weeks' rank
-            # print(f'{team.team_name} rank last week: {lw_rank}')
-            diff = lw_rank - tw_rank  # find the difference between last week to this week
-            # print(f'{team.team_name} weekly change: {diff}')
-            diff = int(diff.item())  # turn into list to iterate over
-            diffs.append(diff)  # append to the list
+    power_rankings = power_rankings.reindex(columns=['Team', 'Power Score'])
 
-        # iterate over diffs list and edit values to include up/down arrow emoji and the number of spots the team moved
-        for item in diffs:
-            if item > 0:
-                emojis.append("**<span style=\"color: green;\">⬆️ " + str(abs(item)) + " </span>**")
-            elif item < 0:
-                emojis.append("**<span style=\"color: red;\">⬇️ " + str(abs(item)) + " </span>**")
-            elif item == 0:
-                emojis.append("")  # adds a index of nothing for teams that didn't move
-
-        power_rankings_df.insert(loc=1, column='Weekly Change', value=emojis)  # insert the weekly change column
-
-    # Set index to start at 1
-    power_rankings_df = power_rankings_df.set_axis(range(1, len(power_rankings_df) + 1))
-
-    return power_rankings_df
-
-def gen_playoff_prob():
-    # Proj wins and losses for rest of season
-
-    # MONTE CARLO PLAYOFF PROBABILITIES
-    print('\nGenerating Monte Carlo Playoff Probabilities...')
-    # number of random season's to simulate
-    simulations = 100000
-    # weeks in the regular season
-    league_weeks = 15
-    # number of teams to playoffs
-    teams_to_play_off = 4
-
-    # team_names:: list of team names. list order is used to
-    # index home_teams and away_teams
-
-    # home_teams, away_teams: list of remaining matchups in the regular season.
-    # Indexes are based on order from team_names
-
-    # current_wins: Integer value represents each team's win count.
-    # The decimal is used to further order teams based on points for eg 644.8 points would be 0.006448.
-    # Order needs to be the same as team_names
-
-    # Create dictionary of teams and id number to be fed to monte carlo simulations
-    # ['Pat'[1], 'Trevor'[2], 'Billy'[3], 'Jack'[4], 'Travis'[5], 'Lucas'[6], 'Cade'[7], 'Christian'[8]]
-    team_dictionary = {'Red Zone  Rockets':1, 'Final Deztination':2, 'Game of  Jones':3, 'Comeback Cardinals':4, 'OC Gang':5, 'Hurts Donit':6, 'Shippin Up To Austin':7, 'Team Ger':8}
-
-    # Initialize empty lists to store the names of home and away teams for each week
-    home_team_names = []
-    away_team_names = []
-
-    # Loop through each week from the current week until the last week of the season
-    for this_week in range(week, 16):
-        # Create emtpy sets to populate with each weeks home and away teams
-        week_home_teams = set()
-        week_away_teams = set()
-
-        # Retrieve the scoreboard for the current week, which contains matchups
-        week_scoreboard = league.scoreboard(this_week)
-
-        # Iterate through each matchup in the scoreboard for the week
-        for matchup in week_scoreboard:
-            # Add the home and away teams' names to the set of home/away teams
-            week_home_teams.add(matchup.home_team.team_name)
-            week_away_teams.add(matchup.away_team.team_name)
-
-        # Append the set of home teams for this week to the list of home team names
-        home_team_names.append(week_home_teams)
-
-        # Append the set of away teams for this week to the list of away team names
-        away_team_names.append(week_away_teams)
-
-    # Flatten the list of sets and replacing team names with their IDs.
-    # Give us a list in order of each weeks home and away teams for the rest of the season
-    home_teams = [team_dictionary[team.strip()] for teams_set in home_team_names for team in teams_set]
-    away_teams = [team_dictionary[team.strip()] for teams_set in away_team_names for team in teams_set]
-
-    # don't need to do below, taken care of in for loop. Format s wins.totalPointsScored as decimal to 6 places
-    # current_wins = [2.010742,3.011697,7.013179,2.010177,6.011863,1.010001,6.012642,5.011502]
-    current_wins = []
-    for team in league.teams:
-        wins = team.wins
-        scores = team.scores
-        total_points_scored = round(sum(scores), 2) / 100000
-        current_wins.append(wins + total_points_scored)
-
-    ###ONLY CONFIGURE THE VALUES ABOVE
-
-    teams = [int(x) for x in range(1, len(league.teams) + 1)]
-    weeks_played = (league_weeks) - ((len(home_teams)) / (len(teams) / 2))
-
-    last_playoff_wins = [0] * (league_weeks)
-    first_playoff_miss = [0] * (league_weeks)
-
-    import datetime
-
-    begin = datetime.datetime.now()
-    import random
-
-    league_size = len(teams)
-
-    games_per_week = int(league_size / 2)
-    weeks_to_play = int(league_weeks - weeks_played)
-    total_games = int(league_weeks * games_per_week)
-    games_left = int(weeks_to_play * games_per_week)
-
-    stats_teams = [0] * (league_size)
-
-    play_off_matrix = [[0 for x in range(teams_to_play_off)] for x in range(league_size)]
-
-    pad = int(games_left)
-
-    avg_wins = [0.0] * teams_to_play_off
-
-    for sims in progressbar.progressbar(range(1, simulations + 1)):
-        # create random binary array representing a single season's results
-        val = [int(random.getrandbits(1)) for x in range(1, (games_left + 1))]
-
-        empty_teams = [0.0] * league_size
-
-        i = 0
-        # assign wins based on 1 or 0 to home or away team
-        for x in val:
-            if (val[i] == 1):
-                empty_teams[home_teams[i] - 1] = empty_teams[home_teams[i] - 1] + 1
-            else:
-                empty_teams[away_teams[i] - 1] = empty_teams[away_teams[i] - 1] + 1
-            i = i + 1
-
-        # add the current wins to the rest of season's results
-        empty_teams = [sum(x) for x in zip(empty_teams, current_wins)]
-
-        # sort the teams
-        sorted_teams = sorted(empty_teams)
-
-        last_playoff_wins[int(round(sorted_teams[(league_size - teams_to_play_off)], 0)) - 1] = last_playoff_wins[int(round(sorted_teams[(league_size - teams_to_play_off)],0)) - 1] + 1
-        first_playoff_miss[int(round(sorted_teams[league_size - (teams_to_play_off + 1)], 0)) - 1] = \
-        first_playoff_miss[int(round(sorted_teams[league_size - (teams_to_play_off + 1)], 0)) - 1] + 1
-
-        # pick the teams making the playoffs
-        for x in range(1, teams_to_play_off + 1):
-            stats_teams[empty_teams.index(sorted_teams[league_size - x])] = stats_teams[empty_teams.index(
-                sorted_teams[league_size - x])] + 1
-            avg_wins[x - 1] = avg_wins[x - 1] + round(sorted_teams[league_size - x], 0)
-            play_off_matrix[empty_teams.index(sorted_teams[league_size - x])][x - 1] = \
-            play_off_matrix[empty_teams.index(sorted_teams[league_size - x])][x - 1] + 1
-
-    projections = []
-
-    playSpots = []
-
-    for x in range(1, len(stats_teams) + 1):
-        vals = ''
-        for y in range(1, teams_to_play_off + 1):
-            vals = vals + '\t' + str(round((play_off_matrix[x - 1][y - 1]) / simulations * 100.0, 2))
-
-            playSpots.append(round((play_off_matrix[x - 1][y - 1]) / simulations * 100.0, 2))
-
-        playProb = round((stats_teams[x - 1]) / simulations * 100.0, 2)
-        playSpots.insert(0, playProb)
-        # print("Vals: ", playSpots)
-        projections.append(playSpots)
-        playSpots = []
-        # print(team_names[x-1]+'\t'+str(round((stats_teams[x-1])/simulations*100.0,2))+vals)
-    # print(f'Pre dataframe projections\n{projections}')
-    # Convert projections to Pandas Dataframe
-    projections = pd.DataFrame(projections)
-
-    # Insert Team Names to DataFrame
-    projections.insert(loc=0, column='Team', value=team_names)
-    projections = projections.set_axis(['Team', 'Playoffs', '1st Seed', '2nd Seed', '3rd Seed', '4th Seed'], axis=1)
-    projections = projections.sort_values(by=['Playoffs', '1st Seed', '2nd Seed', '3rd Seed', '4th Seed'], ascending=False)
-    # projections[['1st Seed','2nd Seed','3rd Seed', '4th Seed']] = projections[['1st Seed','2nd Seed','3rd Seed', '4th Seed']].astype(str) + "%"
-    projections.index = np.arange(1, len(projections) + 1)
-
-    median = projections['Playoffs'].median()
-
-    # bold only the playoff teams
-    for index, row in projections.iterrows():
-        if row['Playoffs'] > median:
-            projections.loc[index, 'Team'] = '**' + str(row['Team']) + '**'
-            projections.loc[index, 'Playoffs'] = '**' + str(row['Playoffs']) + '%**'
-            projections.loc[index, '1st Seed'] = '**' + str(row['1st Seed']) + '%**'
-            projections.loc[index, '2nd Seed'] = '**' + str(row['2nd Seed']) + '%**'
-            projections.loc[index, '3rd Seed'] = '**' + str(row['3rd Seed']) + '%**'
-            projections.loc[index, '4th Seed'] = '**' + str(row['4th Seed']) + '%**'
-        else:
-            projections.loc[index, 'Playoffs'] = str(row['Playoffs']) + '%'
-            projections.loc[index, '1st Seed'] = str(row['1st Seed']) + '%'
-            projections.loc[index, '2nd Seed'] = str(row['2nd Seed']) + '%'
-            projections.loc[index, '3rd Seed'] = str(row['3rd Seed']) + '%'
-            projections.loc[index, '4th Seed'] = str(row['4th Seed']) + '%'
-
-    print('')
-
-    # print('Average # of wins for playoff spot')
-    # for x in range(1,teams_to_play_off+1):
-    #     print(str(x)+'\t'+str(round((avg_wins[x-1])/simulations,2)))
-
-    delta = datetime.datetime.now() - begin
-
-    # print('')
-    # print('Histrogram of wins required for final playoff spot')
-    # for x in range(1,len(last_playoff_wins)+1):
-    #     print(str(x)+'\t'+str(round((last_playoff_wins[x-1])/(simulations*1.0)*100,3))+'\t'+str(round((first_playoff_miss[x-1])/(simulations*1.0)*100,3)))
-
-    print('\n{0:,}'.format(simulations) + " Simulations ran in " + str(delta))
-    print('\nProjections:\n', projections)
-
-    return projections
-
+    return power_rankings
 
 def gen_ai_summary():
-    print("\n\tRetrieving and processing matchups...")
-
     # Retrieve all matchups for the given week
     matchups = league.box_scores(week=week)
 
@@ -347,86 +108,57 @@
     # Convert to JSON format
     box_scores_json = json.dumps(box_scores_data, indent=4)
 
-    print("\n\tGenerating summary with LLM...")
-
-    # Sample JSON data (replace with your actual JSON data)
-    # json_data = box_scores_json
-
     # Setting up OpenAI model
-    llm = ChatOpenAI(model_name="gpt-4o-mini", temperature=0, openai_api_key=api_key)
+    llm = ChatOpenAI(model_name="gpt-4o", temperature=0, openai_api_key=api_key)
 
     # Define the prompt template for generating a newspaper-like summary
     prompt_template = PromptTemplate(
-        input_variables=["box_scores_json"],
+        input_variables=["box_scores_json", "week"],
         template="""
         Write a newspaper-style summary of the fantasy football matchups based on the following JSON data:
 
-        {box_scores_json}
-            
+        {json_data}
+        
         The summary should include:
         - The names of the teams
         - The projected scores for each team
         - Key players and their projected points
         - Any notable points or highlights
+        
+        You should also extensively search the internet for 'NFL Week {week} Storylines'. If a player is noteworthy, include that information with his projected points.
 
         Write in a formal, engaging newspaper tone.
         """
     )
 
     # Initialize the LLMChain with the Llama model and prompt template
-    llm_chain = RunnableSequence(
-        prompt_template | llm
+    llm_chain = LLMChain(
+        llm=llm,
+        prompt=prompt_template
     )
+
+    # Sample JSON data (replace with your actual JSON data)
+    json_data = box_scores_json
 
     # Generate the newspaper-like summary
-    result = llm_chain.invoke(input=box_scores_json)
+    result = llm_chain.invoke(input={"box_score_json": box_scores_json, "week": week})
 
     # return the result
-    return result.content
+    return result
 
 # Generate Power Rankings
-print('\nGenerating Power Rankings...')
 rankings = gen_power_rankings()
 
 # Generate Expected Standings
 
-
 # Generate Playoff Probability (if week 5 or later) and append to expected standings
-if week > 5:
-    playoff_prob = gen_playoff_prob()
 
 # Generate Luck Index
-print('\nGenerating Luck Index...')
-bar_luck_index = progressbar.ProgressBar(max_value=len(teams))
-
-season_luck_index = []
-luck_index_value = 0
-for i, team in enumerate(teams):
-    team_name = team.team_name
-    for luck_week in range(1, week+1):
-        luck_index_value += luck_index.get_weekly_luck_index(league, team, luck_week)
-
-    # append team's season long luck index to the list
-    season_luck_index.append([team.team_name, luck_index_value])
-
-    # reset luck index value
-    luck_index_value = 0
-
-    # Update the progress bar
-    bar_luck_index.update(i + 1)
-
-# convert season long luck index list to pandas dataframe, sort by 'Luck Index', and set index to start at 1
-season_luck_index = pd.DataFrame(season_luck_index, columns=['Team','Luck Index'])
-season_luck_index.sort_values(by='Luck Index', ascending=False, inplace=True, ignore_index=True)
-season_luck_index = season_luck_index.set_axis(range(1, len(season_luck_index)+1))
-
 
 # Generate AI Summary
-print('\n\nGenerating AI Summary...')
 summary = gen_ai_summary()
 
 # Print everything
-print('\nWriting to markdown file...')
 # open text file
 filepath = f"/Users/christiangeer/Fantasy_Sports/football/power_rankings/jtown-dynasty/content/blog/Week{week}{year}PowerRankings.md"
 sys.stdout = open(filepath, "w")
@@ -435,7 +167,7 @@
 print("---")
 print("title: Week", str(week), year, "Report")
 print("date: ",datetime.now().date())
-print(f"image: /images/{year}week{week}.jpg")
+print(f"image: /images/{year}week{week}.jpeg")
 print("draft: true")
 print("---")
 
@@ -447,19 +179,19 @@
 
 # print(table(Value_Power_Rankings_print, headers='keys',tablefmt='pipe', numalign='center')) # have to manually center all play % and weekly change because not an int
 
-print('\n## Summary:\n')
+print('\n##Summary:\n')
 print(summary)
-
 # print("\n# EXPECTED STANDINGS (as of week ", week, ")")
 # league.printExpectedStandings(week)
 # print(table(projectedStandings_prnt, headers='keys', tablefmt='pipe', numalign='center'))
 
-if week >= 5:
-    print(f"\n## PLAYOFF PROBABILITIES (as of week {week}")
-    print(table(playoff_prob, headers='keys', tablefmt='pipe', numalign='center'))
+# if week >= 5:
+#     print("\n# PLAYOFF PROBABILITIES (as of week ", week, ")")
+#     print(table(projections, headers='keys', tablefmt='pipe', numalign='center'))
 
-print("\n## LUCK INDEX")
-print(table(season_luck_index, headers='keys', tablefmt='pipe', numalign='center'))
+
+# print("\n# LUCK INDEX")
+# league.printLuckIndex(week)
 
 # print("\n WEEK ", week, " ALL PLAY STANDINGS (SORT BY WINS)")
 # print(table(allplay, headers='keys', tablefmt='github', numalign='decimal'))
@@ -467,8 +199,5 @@
 # print("\n WEEK ", week, " POWER SCORE (CALC W/ LEAGUE AVERAGE SCORE)")
 # print(table(team_scores_prt, headers='keys', tablefmt='github', numalign='decimal'))
 
-# Close file and restore standard output
+# close text file
 sys.stdout.close()
-sys.stdout = sys.__stdout__
-
-print('\nDone!\n')
