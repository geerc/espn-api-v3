Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nTODO:\n1. After week 1 check that expected standings are lining up teams correctly when adding back to dataframe after simulation\n2. Use player values to inform AI summary\n4. Create CRON job to run automatically\n\"\"\"\nfrom langchain_core.runnables import RunnableSequence\n\nimport pandas as pd\nfrom tabulate import tabulate as table\nimport sys\nimport argparse\nfrom espn_api.football import League\nfrom datetime import datetime\nimport re\nimport json\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain_openai import ChatOpenAI\nimport os\nfrom dotenv import load_dotenv\nfrom doritostats import luck_index\nimport time\nimport progressbar\nfrom fuzzywuzzy import fuzz\nfrom fuzzywuzzy import process\nimport numpy as np\n\n# Define dates/year\nyear = datetime.now().year\nmonth =  datetime.now().month\nday = datetime.now().day\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Get login credentials for leagues\nleague_id = os.getenv('league_id')\nswid = os.getenv('swid')\nespn_s2 = os.getenv('espn_s2')\napi_key= os.getenv('OPEN_AI_KEY')\n\nleague = League(league_id, year, espn_s2, swid)\n\n# Get NFL week\nweek = league.nfl_week - 1\n# week = 6\n\nprint(league, \"\\n\", f'Week {week}')\n\n# Create list of teams\nteams = league.teams\n\n\ndef fuzzy_merge(df1, df2, key1, key2, threshold=90, limit=1):\n    \"\"\"\n    Perform fuzzy merge between two DataFrames based on the similarity of the values in key1 and key2.\n    Parameters:\n    - df1: First DataFrame.\n    - df2: Second DataFrame.\n    - key1: Column in df1 to match.\n    - key2: Column in df2 to match.\n    - threshold: Similarity threshold (0-100).\n    - limit: Maximum number of matches to return per key.\n    \"\"\"\n    matches = df1[key1].apply(\n        lambda x: process.extractOne(x, df2[key2], scorer=fuzz.token_sort_ratio, score_cutoff=threshold))\n\n    df1['Best Match'] = matches.apply(lambda x: x[0] if x is not None else None)\n    df1['Match Score'] = matches.apply(lambda x: x[1] if x is not None else None)\n\n    # Merge on the 'Best Match' instead of the original key\n    merged_df = pd.merge(df1, df2, left_on='Best Match', right_on=key2, how='left')\n\n    return merged_df\n\ndef gen_power_rankings():\n    power_rankings = league.power_rankings(week=week)\n\n    # Extract team names\n    extracted_team_names = [(record, re.sub(r'Team\\((.*?)\\)', r'\\1', str(team))) #convert team object to string\n        for record, team in power_rankings]\n\n    # Convert to Dataframe\n    power_rankings = pd.DataFrame(extracted_team_names, columns=['Power Score','Team'])\n\n\n    # Switch Score and Team Name cols\n    power_rankings_df = power_rankings.reindex(columns=['Team', 'Power Score'])\n\n    if week > 1:\n        # Generate last weeks' power rankings for comparison\n        prev_power_rankings = league.power_rankings(week=week-1)\n\n        # Extract team names\n        extracted_team_names = [(record, re.sub(r'Team\\((.*?)\\)', r'\\1', str(team)))  # convert team object to string\n                                for record, team in prev_power_rankings]\n\n        # Convert to Dataframe\n        prev_power_rankings_df = pd.DataFrame(extracted_team_names, columns=['Power Score', 'Team'])\n\n        # Switch Score and Team Name cols\n        prev_power_rankings_df = prev_power_rankings_df.reindex(columns=['Team', 'Power Score'])\n\n        diffs = []\n        emojis = []\n\n        print('This week: \\n', power_rankings_df)\n        print('Last week: \\n', prev_power_rankings_df)\n\n        for team in league.teams:\n            # print(team)\n            tw_rank = power_rankings_df[power_rankings_df['Team'] == team.team_name].index.values  # get this week's rank\n            # print(f'{team.team_name} rank this week: {tw_rank}')\n            lw_rank = prev_power_rankings_df[prev_power_rankings_df['Team'] == team.team_name].index.values  # get last weeks' rank\n            # print(f'{team.team_name} rank last week: {lw_rank}')\n            diff = lw_rank - tw_rank  # find the difference between last week to this week\n            # print(f'{team.team_name} weekly change: {diff}')\n            diff = int(diff.item())  # turn into list to iterate over\n            diffs.append(diff)  # append to the list\n\n        # iterate over diffs list and edit values to include up/down arrow emoji and the number of spots the team moved\n        for item in diffs:\n            if item > 0:\n                emojis.append(\"**<span style=\\\"color: green;\\\">⬆\uFE0F \" + str(abs(item)) + \" </span>**\")\n            elif item < 0:\n                emojis.append(\"**<span style=\\\"color: red;\\\">⬇\uFE0F \" + str(abs(item)) + \" </span>**\")\n            elif item == 0:\n                emojis.append(\"\")  # adds a index of nothing for teams that didn't move\n\n        power_rankings_df.insert(loc=1, column='Weekly Change', value=emojis)  # insert the weekly change column\n\n    # Integrate player values into Power Rankings\n\n    # Load players values for the week\n    player_values = pd.read_csv(f'/Users/christiangeer/Fantasy_Sports/football/power_rankings/espn-api-v3/player_values/KTC_values_week{week}.csv')\n\n    # Generate DataFrame of Team Rosters\n    league_rosters = []\n    for team in league.teams:\n        # Get list of player objects for each team\n        team_roster = team.roster\n\n        for player in team_roster:\n            # Append player name, position and the team that they're on\n            league_rosters.append([team.team_name, player.name, player.position])\n\n    league_rosters_df = pd.DataFrame(league_rosters, columns=['Team','Player','Position'])\n\n    # Remove the number at the end of the 'Pos' values\n    player_values['Pos'] = player_values['Pos'].str.extract(r'(\\D+)')\n\n    # Filter out defenses and PKs\n    league_rosters_filtered = league_rosters_df[~league_rosters_df['Position'].isin(['D/ST', 'PK'])]\n    player_values_filtered = player_values[~player_values['Pos'].isin(['DST', 'PK'])]\n\n    # Perform fuzzy merge to match slightly different player names\n    player_values_fuzzy_merged = fuzzy_merge(\n        player_values_filtered[['Player Name', 'Pos', 'Value']],\n        league_rosters_filtered[['Player', 'Team']],  # Ensure 'Team' is included in the merge\n        'Player Name',\n        'Player',\n        threshold=90\n    )\n\n    # Select and rename the final columns as 'Player Name', 'Pos', 'Value', and 'Team'\n    final_df = player_values_fuzzy_merged[['Player Name', 'Pos', 'Value', 'Team']]\n\n    # Check for rostered players without exact value matches\n    roster_check = final_df[(final_df['Value'] == 'NaN') | (final_df['Pos'] == 'NaN')]  # Checking for unmatched players\n    print(f'\\n\\tCheck for rostered players without exact matches:\\n{roster_check}')\n\n    # Group by 'Team' and 'Position', summing 'Value'\n    team_pos_values = final_df.groupby(['Team', 'Pos'], as_index=False)['Value'].sum()\n\n    # Rename columns to keep consistency\n    team_pos_values.rename(columns={'Position': 'Pos'}, inplace=True)\n\n    # Group by position to get total team value\n    team_values = team_pos_values.groupby(['Team'], as_index=False)['Value'].sum()\n\n    # power_rankings and values\n    power_rankings_df = power_rankings_df.merge(team_values, on='Team')\n\n    # Convert 'Power Score' to numeric, forcing errors to NaN\n    power_rankings_df['Power Score'] = pd.to_numeric(power_rankings_df['Power Score'].str.replace(',', '').str.replace('$', ''),\n                                            errors='coerce')\n\n    # Normalize 'Power Score' and 'Value' using min-max normalization\n    power_rankings_df['Power Score Normalized'] = (power_rankings_df['Power Score'] - power_rankings_df['Power Score'].min()) / (\n                power_rankings_df['Power Score'].max() - power_rankings_df['Power Score'].min())\n    power_rankings_df['Value Normalized'] = (power_rankings_df['Value'] - power_rankings_df['Value'].min()) / (power_rankings_df['Value'].max() - power_rankings_df['Value'].min())\n\n    # Parameters for the weight function to achieve f(1) ~ 0.5 and f(15) ~ .1\n    a = 0.5585\n    b = -0.1147\n\n    # Calculate the weight for the 'Value' column\n    value_weight = round(a * np.exp(b * week), 2)\n\n    # Calculate the weight for 'Power Score'\n    power_score_weight = 1 - value_weight\n\n    # Calculate the new power score using the weights\n    power_rankings_df['New Power Score'] = (power_rankings_df['Power Score Normalized'] * power_score_weight +\n                                            power_rankings_df['Value Normalized'] * value_weight) / \\\n                                           (power_score_weight + value_weight)\n\n    # Drop the intermediate columns\n    power_rankings_df = power_rankings_df.drop(columns=['Power Score Normalized', 'Value Normalized'])\n\n    # Sort by new power score\n    power_rankings_df = power_rankings_df.sort_values(by=['New Power Score'], ascending=False)\n\n    # Rename columns for output\n    power_rankings_df = power_rankings_df.rename(columns={'Power Score':'Performance Score', 'Value':'KTC Value', 'New Power Score':'Power Score'})\n\n    # Divide Performance score by 100 for readability\n    power_rankings_df['KTC Value'] = round(power_rankings_df['KTC Value'] / 100, 2)\n\n    # Multiply power  score by 100, round to 2 decimals\n    power_rankings_df['Power Score'] = round(power_rankings_df['Power Score'] * 100, 2)\n\n    # Rank 'Performance Score' in descending order\n    power_rankings_df['Performance Rank'] = power_rankings_df['Performance Score'].rank(ascending=False)\n\n    # Rank 'KTC Value' in descending order\n    power_rankings_df['KTC Value Rank'] = power_rankings_df['KTC Value'].rank(ascending=False)\n\n    # Drop the original 'Performance Score' and 'KTC Value' columns\n    power_rankings_df = power_rankings_df.drop(columns=['Performance Score', 'KTC Value'])\n\n    # Set index to start at 1\n    power_rankings_df = power_rankings_df.set_axis(range(1, len(power_rankings_df) + 1))\n\n    return power_rankings_df\n\ndef gen_playoff_prob():\n    # Proj wins and losses for rest of season\n\n    # MONTE CARLO PLAYOFF PROBABILITIES\n    print('\\nGenerating Monte Carlo Playoff Probabilities...')\n\n    # number of random season's to simulate\n    simulations = 100000\n    # weeks in the regular season\n    league_weeks = 15\n    # number of teams to playoffs\n    teams_to_play_off = 4\n\n    \"\"\"\n    team_names:: list of team names. list order is used to\n    index home_teams and away_teams\n\n    home_teams, away_teams: list of remaining matchups in the regular season.\n    Indexes are based on order from team_names\n\n    current_wins: Integer value represents each team's win count.\n    The decimal is used to further order teams based on points for eg 644.8 points would be 0.006448.\n    Order needs to be the same as team_names\n    \"\"\"\n\n    # Create dictionary of teams and id number to be fed to monte carlo simulations\n    # ['Pat'[1], 'Trevor'[2], 'Billy'[3], 'Jack'[4], 'Travis'[5], 'Lucas'[6], 'Cade'[7], 'Christian'[8]]\n    team_dictionary = {'Red Zone  Rockets':1, 'Final Deztination':2, 'Game of  Jones':3, 'Comeback Cardinals':4, 'OC Gang':5, 'Hurts Donit':6, 'Shippin Up To Austin':7, 'Team Ger':8}\n\n    # Initialize empty lists to store the names of home and away teams for each week\n    home_team_names = []\n    away_team_names = []\n\n    # Loop through each week from the current week until the last week of the season\n    for this_week in range(week, 16):\n        # Create emtpy sets to populate with each weeks home and away teams\n        week_home_teams = set()\n        week_away_teams = set()\n\n        # Retrieve the scoreboard for the current week, which contains matchups\n        week_scoreboard = league.scoreboard(this_week)\n\n        # Iterate through each matchup in the scoreboard for the week\n        for matchup in week_scoreboard:\n            # Add the home and away teams' names to the set of home/away teams\n            week_home_teams.add(matchup.home_team.team_name)\n            week_away_teams.add(matchup.away_team.team_name)\n\n        # Append the set of home teams for this week to the list of home team names\n        home_team_names.append(week_home_teams)\n\n        # Append the set of away teams for this week to the list of away team names\n        away_team_names.append(week_away_teams)\n\n    # Flatten the list of sets and replacing team names with their IDs.\n    # Give us a list in order of each weeks home and away teams for the rest of the season\n    home_teams = [team_dictionary[team.strip()] for teams_set in home_team_names for team in teams_set]\n    away_teams = [team_dictionary[team.strip()] for teams_set in away_team_names for team in teams_set]\n\n    # don't need to do below, taken care of in for loop. Format s wins.totalPointsScored as decimal to 6 places\n    # current_wins = [2.010742,3.011697,7.013179,2.010177,6.011863,1.010001,6.012642,5.011502]\n    current_wins = []\n    for team in league.teams:\n        wins = team.wins\n        scores = team.scores\n        total_points_scored = round(sum(scores), 2) / 100000\n        current_wins.append(wins + total_points_scored)\n\n    ###ONLY CONFIGURE THE VALUES ABOVE\n\n    teams = [int(x) for x in range(1, len(league.teams) + 1)]\n    weeks_played = (league_weeks) - ((len(home_teams)) / (len(teams) / 2))\n\n    last_playoff_wins = [0] * (league_weeks)\n    first_playoff_miss = [0] * (league_weeks)\n\n    import datetime\n\n    begin = datetime.datetime.now()\n    import random\n\n    league_size = len(teams)\n\n    games_per_week = int(league_size / 2)\n    weeks_to_play = int(league_weeks - weeks_played)\n    total_games = int(league_weeks * games_per_week)\n    games_left = int(weeks_to_play * games_per_week)\n\n    stats_teams = [0] * (league_size)\n\n    play_off_matrix = [[0 for x in range(teams_to_play_off)] for x in range(league_size)]\n\n    pad = int(games_left)\n\n    avg_wins = [0.0] * teams_to_play_off\n\n    for sims in progressbar.progressbar(range(1, simulations + 1)):\n        # create random binary array representing a single season's results\n        val = [int(random.getrandbits(1)) for x in range(1, (games_left + 1))]\n\n        empty_teams = [0.0] * league_size\n\n        i = 0\n        # assign wins based on 1 or 0 to home or away team\n        for x in val:\n            if (val[i] == 1):\n                empty_teams[home_teams[i] - 1] = empty_teams[home_teams[i] - 1] + 1\n            else:\n                empty_teams[away_teams[i] - 1] = empty_teams[away_teams[i] - 1] + 1\n            i = i + 1\n\n        # add the current wins to the rest of season's results\n        empty_teams = [sum(x) for x in zip(empty_teams, current_wins)]\n\n        # sort the teams\n        sorted_teams = sorted(empty_teams)\n\n        last_playoff_wins[int(round(sorted_teams[(league_size - teams_to_play_off)], 0)) - 1] = last_playoff_wins[int(round(sorted_teams[(league_size - teams_to_play_off)],0)) - 1] + 1\n        first_playoff_miss[int(round(sorted_teams[league_size - (teams_to_play_off + 1)], 0)) - 1] = \\\n        first_playoff_miss[int(round(sorted_teams[league_size - (teams_to_play_off + 1)], 0)) - 1] + 1\n\n        # pick the teams making the playoffs\n        for x in range(1, teams_to_play_off + 1):\n            stats_teams[empty_teams.index(sorted_teams[league_size - x])] = stats_teams[empty_teams.index(\n                sorted_teams[league_size - x])] + 1\n            avg_wins[x - 1] = avg_wins[x - 1] + round(sorted_teams[league_size - x], 0)\n            play_off_matrix[empty_teams.index(sorted_teams[league_size - x])][x - 1] = \\\n            play_off_matrix[empty_teams.index(sorted_teams[league_size - x])][x - 1] + 1\n\n    projections = []\n\n    playSpots = []\n\n    for x in range(1, len(stats_teams) + 1):\n        vals = ''\n        for y in range(1, teams_to_play_off + 1):\n            vals = vals + '\\t' + str(round((play_off_matrix[x - 1][y - 1]) / simulations * 100.0, 2))\n\n            playSpots.append(round((play_off_matrix[x - 1][y - 1]) / simulations * 100.0, 2))\n\n        playProb = round((stats_teams[x - 1]) / simulations * 100.0, 2)\n        playSpots.insert(0, playProb)\n        # print(\"Vals: \", playSpots)\n        projections.append(playSpots)\n        playSpots = []\n        # print(team_names[x-1]+'\\t'+str(round((stats_teams[x-1])/simulations*100.0,2))+vals)\n    # print(f'Pre dataframe projections\\n{projections}')\n    # Convert projections to Pandas Dataframe\n    projections = pd.DataFrame(projections)\n\n    # Insert Team Names to DataFrame\n    projections.insert(loc=0, column='Team', value=team_names)\n    projections = projections.set_axis(['Team', 'Playoffs', '1st Seed', '2nd Seed', '3rd Seed', '4th Seed'], axis=1)\n    projections = projections.sort_values(by=['Playoffs', '1st Seed', '2nd Seed', '3rd Seed', '4th Seed'], ascending=False)\n    # projections[['1st Seed','2nd Seed','3rd Seed', '4th Seed']] = projections[['1st Seed','2nd Seed','3rd Seed', '4th Seed']].astype(str) + \"%\"\n    projections.index = np.arange(1, len(projections) + 1)\n\n    median = projections['Playoffs'].median()\n\n    # bold only the playoff teams\n    for index, row in projections.iterrows():\n        if row['Playoffs'] > median:\n            projections.loc[index, 'Team'] = '**' + str(row['Team']) + '**'\n            projections.loc[index, 'Playoffs'] = '**' + str(row['Playoffs']) + '%**'\n            projections.loc[index, '1st Seed'] = '**' + str(row['1st Seed']) + '%**'\n            projections.loc[index, '2nd Seed'] = '**' + str(row['2nd Seed']) + '%**'\n            projections.loc[index, '3rd Seed'] = '**' + str(row['3rd Seed']) + '%**'\n            projections.loc[index, '4th Seed'] = '**' + str(row['4th Seed']) + '%**'\n        else:\n            projections.loc[index, 'Playoffs'] = str(row['Playoffs']) + '%'\n            projections.loc[index, '1st Seed'] = str(row['1st Seed']) + '%'\n            projections.loc[index, '2nd Seed'] = str(row['2nd Seed']) + '%'\n            projections.loc[index, '3rd Seed'] = str(row['3rd Seed']) + '%'\n            projections.loc[index, '4th Seed'] = str(row['4th Seed']) + '%'\n\n    print('')\n\n    # print('Average # of wins for playoff spot')\n    # for x in range(1,teams_to_play_off+1):\n    #     print(str(x)+'\\t'+str(round((avg_wins[x-1])/simulations,2)))\n\n    delta = datetime.datetime.now() - begin\n\n    # print('')\n    # print('Histrogram of wins required for final playoff spot')\n    # for x in range(1,len(last_playoff_wins)+1):\n    #     print(str(x)+'\\t'+str(round((last_playoff_wins[x-1])/(simulations*1.0)*100,3))+'\\t'+str(round((first_playoff_miss[x-1])/(simulations*1.0)*100,3)))\n\n    print('\\n{0:,}'.format(simulations) + \" Simulations ran in \" + str(delta))\n    print('\\nProjections:\\n', projections)\n\n    return projections\n\n\ndef gen_ai_summary():\n    print(\"\\n\\tRetrieving and processing matchups...\")\n\n    # Retrieve all matchups for the given week\n    matchups = league.box_scores(week=week)\n\n    # Extract box score data\n    box_scores_data = []\n\n    for matchup in matchups:\n        matchup_data = {\n            \"home_team\": matchup.home_team.team_name,\n            \"home_score\": matchup.home_score,\n            \"home_projected\": matchup.home_projected,\n            \"away_team\": matchup.away_team.team_name,\n            \"away_score\": matchup.away_score,\n            \"away_projected\": matchup.away_projected,\n            \"home_players\": [\n                {\n                    \"player_name\": player.name,\n                    \"slot_position\": player.slot_position,\n                    \"position\": player.position,\n                    \"points\": player.points,\n                    \"projected_points\": player.projected_points\n                } for player in matchup.home_lineup\n            ],\n            \"away_players\": [\n                {\n                    \"player_name\": player.name,\n                    \"position\": player.position,\n                    \"slot_position\": player.slot_position,\n                    \"points\": player.points,\n                    \"projected_points\": player.projected_points\n                } for player in matchup.away_lineup\n            ]\n        }\n        box_scores_data.append(matchup_data)\n\n    # Convert to JSON format\n    box_scores_json = json.dumps(box_scores_data, indent=4)\n\n    print(\"\\n\\tGenerating summary with LLM...\")\n\n    # Sample JSON data (replace with your actual JSON data)\n    # json_data = box_scores_json\n\n    # Setting up OpenAI model\n    llm = ChatOpenAI(model_name=\"gpt-4o-mini\", temperature=0, openai_api_key=api_key)\n\n    # Define the prompt template for generating a newspaper-like summary\n    prompt_template = PromptTemplate(\n        input_variables=[\"box_scores_json\"],\n        template=\"\"\"\n        Write a newspaper-style summary of the fantasy football matchups based on the following JSON data:\n\n        {box_scores_json}\n            \n        The summary should include:\n        - The names of the teams\n        - The projected scores for each team\n        - Key players and their projected points\n        - Any notable points or highlights\n\n        Write in a formal, engaging newspaper tone.\n        \"\"\"\n    )\n\n    # Initialize the LLMChain with the Llama model and prompt template\n    llm_chain = RunnableSequence(\n        prompt_template | llm\n    )\n\n    # Generate the newspaper-like summary\n    result = llm_chain.invoke(input=box_scores_json)\n\n    # return the result\n    return result.content\n\n# Generate Power Rankings\nprint('\\nGenerating Power Rankings...')\nrankings = gen_power_rankings()\n\n# Generate Expected Standings\n\n\n# Generate Playoff Probability (if week 5 or later) and append to expected standings\nif week > 5:\n    playoff_prob = gen_playoff_prob()\n\n# Generate Luck Index\nprint('\\nGenerating Luck Index...')\nbar_luck_index = progressbar.ProgressBar(max_value=len(teams))\n\nseason_luck_index = []\nluck_index_value = 0\nfor i, team in enumerate(teams):\n    team_name = team.team_name\n    for luck_week in range(1, week+1):\n        luck_index_value += luck_index.get_weekly_luck_index(league, team, luck_week)\n\n    # append team's season long luck index to the list\n    season_luck_index.append([team.team_name, luck_index_value])\n\n    # reset luck index value\n    luck_index_value = 0\n\n    # Update the progress bar\n    bar_luck_index.update(i + 1)\n\n# convert season long luck index list to pandas dataframe, sort by 'Luck Index', and set index to start at 1\nseason_luck_index = pd.DataFrame(season_luck_index, columns=['Team','Luck Index'])\nseason_luck_index.sort_values(by='Luck Index', ascending=False, inplace=True, ignore_index=True)\nseason_luck_index = season_luck_index.set_axis(range(1, len(season_luck_index)+1))\n\n\n# Generate AI Summary\nprint('\\n\\nGenerating AI Summary...')\nsummary = gen_ai_summary()\n\n# Print everything\nprint('\\nWriting to markdown file...')\n# open text file\nfilepath = f\"/Users/christiangeer/Fantasy_Sports/football/power_rankings/jtown-dynasty/content/blog/Week{week}{year}PowerRankings.md\"\nsys.stdout = open(filepath, \"w\")\n\n# for the markdown files in blog\nprint(\"---\")\nprint(\"title: Week\", str(week), year, \"Report\")\nprint(\"date: \",datetime.now().date())\nprint(f\"image: /images/{year}week{week}.jpg\")\nprint(\"draft: true\")\nprint(\"---\")\n\nprint(\"<!-- excerpt -->\")\n\nprint(\"\\n# POWER RANKINGS\\n\")\n# Value un-informed\nprint(table(rankings, headers='keys', tablefmt='pipe', numalign='center')) # have to manually center all play % because its not a number\n\n# print(table(Value_Power_Rankings_print, headers='keys',tablefmt='pipe', numalign='center')) # have to manually center all play % and weekly change because not an int\n\nprint('\\n## Summary:\\n')\nprint(summary)\n\n# print(\"\\n# EXPECTED STANDINGS (as of week \", week, \")\")\n# league.printExpectedStandings(week)\n# print(table(projectedStandings_prnt, headers='keys', tablefmt='pipe', numalign='center'))\n\nif week >= 5:\n    print(f\"\\n## PLAYOFF PROBABILITIES (as of week {week}\")\n    print(table(playoff_prob, headers='keys', tablefmt='pipe', numalign='center'))\n\nprint(\"\\n## LUCK INDEX\")\nprint(table(season_luck_index, headers='keys', tablefmt='pipe', numalign='center'))\n\n# print(\"\\n WEEK \", week, \" ALL PLAY STANDINGS (SORT BY WINS)\")\n# print(table(allplay, headers='keys', tablefmt='github', numalign='decimal'))\n\n# print(\"\\n WEEK \", week, \" POWER SCORE (CALC W/ LEAGUE AVERAGE SCORE)\")\n# print(table(team_scores_prt, headers='keys', tablefmt='github', numalign='decimal'))\n\n# Close file and restore standard output\nsys.stdout.close()\nsys.stdout = sys.__stdout__\n\nprint('\\nDone!\\n')\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 32d9616d2c6039ec1c740cb7450375fab20b3ae3)
+++ b/main.py	(date 1726237351473)
@@ -168,7 +168,7 @@
     # Check for rostered players without exact value matches
     roster_check = final_df[(final_df['Value'] == 'NaN') | (final_df['Pos'] == 'NaN')]  # Checking for unmatched players
     print(f'\n\tCheck for rostered players without exact matches:\n{roster_check}')
-
+    # TODO: If >0 unmatched players, print them
     # Group by 'Team' and 'Position', summing 'Value'
     team_pos_values = final_df.groupby(['Team', 'Pos'], as_index=False)['Value'].sum()
 
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"187ec636-716f-4623-8c9b-b50a2d7c0e3f\" name=\"Changes\" comment=\"\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/main.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/main.py\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"player_values\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n    <option name=\"ROOT_SYNC\" value=\"DONT_SYNC\" />\n    <option name=\"SWAP_SIDES_IN_COMPARE_BRANCHES\" value=\"true\" />\n  </component>\n  <component name=\"ProjectColorInfo\">{\n  &quot;associatedIndex&quot;: 6\n}</component>\n  <component name=\"ProjectId\" id=\"2lIiGQMmMNYHpxoityGbS15jBFK\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\"><![CDATA[{\n  \"keyToString\": {\n    \"Python.main.executor\": \"Run\",\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\n    \"git-widget-placeholder\": \"player__values\",\n    \"last_opened_file_path\": \"/Users/christiangeer/Fantasy_Sports/football/power_rankings/espn-api-v3\",\n    \"settings.editor.selected.configurable\": \"project.propVCSSupport.CommitDialog\"\n  }\n}]]></component>\n  <component name=\"RecentsManager\">\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/doritostats\" />\n    </key>\n  </component>\n  <component name=\"RunManager\">\n    <configuration name=\"main\" type=\"PythonConfigurationType\" factoryName=\"Python\" nameIsGenerated=\"true\">\n      <module name=\"espn-api-v3\" />\n      <option name=\"ENV_FILES\" value=\"\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/main.py\" />\n      <option name=\"PARAMETERS\" value=\"1\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n  </component>\n  <component name=\"SharedIndexes\">\n    <attachedChunks>\n      <set>\n        <option value=\"bundled-python-sdk-ce3d9afa04ac-ba05f1cad1b1-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-242.20224.347\" />\n      </set>\n    </attachedChunks>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"187ec636-716f-4623-8c9b-b50a2d7c0e3f\" name=\"Changes\" comment=\"\" />\n      <created>1724873895265</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1724873895265</updated>\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"Getting box score JSON data to feed to LLM\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1725384218644</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1725384218644</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"Set up LLM chain with prompt template\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1725469954851</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1725469954851</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"function to generate expected standings\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1725639060662</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1725639060663</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"4\" />\n    <servers />\n  </component>\n  <component name=\"UnknownFeatures\">\n    <option featureType=\"com.intellij.fileTypeFactory\" implementationName=\".env\" />\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <option name=\"CLEAR_INITIAL_COMMIT_MESSAGE\" value=\"true\" />\n    <MESSAGE value=\"Getting box score JSON data to feed to LLM\" />\n    <MESSAGE value=\"Set up LLM chain with prompt template\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 32d9616d2c6039ec1c740cb7450375fab20b3ae3)
+++ b/.idea/workspace.xml	(date 1726237231548)
@@ -32,15 +32,15 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent"><![CDATA[{
-  "keyToString": {
-    "Python.main.executor": "Run",
-    "RunOnceActivity.ShowReadmeOnStart": "true",
-    "git-widget-placeholder": "player__values",
-    "last_opened_file_path": "/Users/christiangeer/Fantasy_Sports/football/power_rankings/espn-api-v3",
-    "settings.editor.selected.configurable": "project.propVCSSupport.CommitDialog"
+  <component name="PropertiesComponent">{
+  &quot;keyToString&quot;: {
+    &quot;Python.main.executor&quot;: &quot;Run&quot;,
+    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
+    &quot;git-widget-placeholder&quot;: &quot;player__values&quot;,
+    &quot;last_opened_file_path&quot;: &quot;/Users/christiangeer/Fantasy_Sports/football/power_rankings/espn-api-v3&quot;,
+    &quot;settings.editor.selected.configurable&quot;: &quot;project.propVCSSupport.CommitDialog&quot;
   }
-}]]></component>
+}</component>
   <component name="RecentsManager">
     <key name="MoveFile.RECENT_KEYS">
       <recent name="$PROJECT_DIR$/doritostats" />
