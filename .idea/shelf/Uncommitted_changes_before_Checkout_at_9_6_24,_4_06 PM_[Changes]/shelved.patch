Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>'''\nTODO:\n1. After week 1 check that expected standings are lining up teams correctly when adding back to dataframe after simulation\n2. Update player values to pull from KTC\n3. Use player values to inform AI summary\n4. Create CRON job to run automatically\n5. Update args to default to current week if not specified\n'''\nfrom langchain_core.runnables import RunnableSequence\n\nimport pandas as pd\nfrom tabulate import tabulate as table\nimport sys\nimport argparse\nfrom espn_api.football import League\nfrom datetime import datetime\nimport re\nimport json\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain_openai import ChatOpenAI\nimport os\nfrom dotenv import load_dotenv\nfrom doritostats import luck_index\nimport time\nimport progressbar\nimport numpy as np\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"week\", help='Get week of the NFL season to run rankings for')\nargs = parser.parse_args()\nweek = int(args.week)\n\n# Define dates/year\nyear = datetime.now().year\nmonth =  datetime.now().month\nday = datetime.now().day\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Get login credentials for leagues\nleague_id = os.getenv('league_id')\nswid = os.getenv('swid')\nespn_s2 = os.getenv('espn_s2')\napi_key= os.getenv('OPEN_AI_KEY')\n\nleague = League(league_id, year, espn_s2, swid)\nprint(league, \"\\n\")\n\n# Create list of teams\nteams = league.teams\n\n# Create list of team names\nteam_names = [team_obj.team_name for team_obj in league.teams]\n\n\ndef gen_power_rankings():\n    power_rankings = league.power_rankings(week=week)\n\n    # Extract team names\n    extracted_team_names = [(record, re.sub(r'Team\\((.*?)\\)', r'\\1', str(team))) #convert team object to string\n        for record, team in power_rankings]\n\n    # Convert to Dataframe\n    power_rankings = pd.DataFrame(extracted_team_names, columns=['Power Score','Team'])\n\n\n    # Switch Score and Team Name cols\n    power_rankings_df = power_rankings.reindex(columns=['Team', 'Power Score'])\n\n    if week > 1:\n        # Generate last weeks' power rankings for comparison\n        prev_power_rankings = league.power_rankings(week=week-1)\n\n        # Extract team names\n        extracted_team_names = [(record, re.sub(r'Team\\((.*?)\\)', r'\\1', str(team)))  # convert team object to string\n                                for record, team in prev_power_rankings]\n\n        # Convert to Dataframe\n        prev_power_rankings_df = pd.DataFrame(extracted_team_names, columns=['Power Score', 'Team'])\n\n        # Switch Score and Team Name cols\n        prev_power_rankings_df = prev_power_rankings_df.reindex(columns=['Team', 'Power Score'])\n\n        diffs = []\n        emojis = []\n\n        print('This week: \\n', power_rankings_df)\n        print('Last week: \\n', prev_power_rankings_df)\n\n        for team in league.teams:\n            # print(team)\n            tw_rank = power_rankings_df[power_rankings_df['Team'] == team.team_name].index.values  # get this week's rank\n            # print(f'{team.team_name} rank this week: {tw_rank}')\n            lw_rank = prev_power_rankings_df[prev_power_rankings_df['Team'] == team.team_name].index.values  # get last weeks' rank\n            # print(f'{team.team_name} rank last week: {lw_rank}')\n            diff = lw_rank - tw_rank  # find the difference between last week to this week\n            # print(f'{team.team_name} weekly change: {diff}')\n            diff = int(diff.item())  # turn into list to iterate over\n            diffs.append(diff)  # append to the list\n\n        # iterate over diffs list and edit values to include up/down arrow emoji and the number of spots the team moved\n        for item in diffs:\n            if item > 0:\n                emojis.append(\"**<span style=\\\"color: green;\\\">⬆\uFE0F \" + str(abs(item)) + \" </span>**\")\n            elif item < 0:\n                emojis.append(\"**<span style=\\\"color: red;\\\">⬇\uFE0F \" + str(abs(item)) + \" </span>**\")\n            elif item == 0:\n                emojis.append(\"\")  # adds a index of nothing for teams that didn't move\n\n        power_rankings_df.insert(loc=1, column='Weekly Change', value=emojis)  # insert the weekly change column\n\n    return power_rankings_df\n\ndef gen_playoff_prob():\n    # Proj wins and losses for rest of season\n\n    # MONTE CARLO PLAYOFF PROBABILITIES\n    print('\\nGenerating Monte Carlo Playoff Probabilities...')\n    # number of random season's to simulate\n    simulations = 100000\n    # weeks in the regular season\n    league_weeks = 15\n    # number of teams to playoffs\n    teams_to_play_off = 4\n\n    # team_names:: list of team names. list order is used to\n    # index home_teams and away_teams\n\n    # home_teams, away_teams: list of remaining matchups in the regular season.\n    # Indexes are based on order from team_names\n\n    # current_wins: Integer value represents each team's win count.\n    # The decimal is used to further order teams based on points for eg 644.8 points would be 0.006448.\n    # Order needs to be the same as team_names\n\n    # Create dictionary of teams and id number to be fed to monte carlo simulations\n    # ['Pat'[1], 'Trevor'[2], 'Billy'[3], 'Jack'[4], 'Travis'[5], 'Lucas'[6], 'Cade'[7], 'Christian'[8]]\n    team_dictionary = {'Red Zone  Rockets':1, 'Final Deztination':2, 'Game of  Jones':3, 'Comeback Cardinals':4, 'OC Gang':5, 'Hurts Donit':6, 'Shippin Up To Austin':7, 'Team Ger':8}\n\n    # Initialize empty lists to store the names of home and away teams for each week\n    home_team_names = []\n    away_team_names = []\n\n    # Loop through each week from the current week until the last week of the season\n    for this_week in range(week, 16):\n        # Create emtpy sets to populate with each weeks home and away teams\n        week_home_teams = set()\n        week_away_teams = set()\n\n        # Retrieve the scoreboard for the current week, which contains matchups\n        week_scoreboard = league.scoreboard(this_week)\n\n        # Iterate through each matchup in the scoreboard for the week\n        for matchup in week_scoreboard:\n            # Add the home and away teams' names to the set of home/away teams\n            week_home_teams.add(matchup.home_team.team_name)\n            week_away_teams.add(matchup.away_team.team_name)\n\n        # Append the set of home teams for this week to the list of home team names\n        home_team_names.append(week_home_teams)\n\n        # Append the set of away teams for this week to the list of away team names\n        away_team_names.append(week_away_teams)\n\n    # Flatten the list of sets and replacing team names with their IDs.\n    # Give us a list in order of each weeks home and away teams for the rest of the season\n    home_teams = [team_dictionary[team.strip()] for teams_set in home_team_names for team in teams_set]\n    away_teams = [team_dictionary[team.strip()] for teams_set in away_team_names for team in teams_set]\n\n    # don't need to do below, taken care of in for loop. Format s wins.totalPointsScored as decimal to 6 places\n    # current_wins = [2.010742,3.011697,7.013179,2.010177,6.011863,1.010001,6.012642,5.011502]\n    current_wins = []\n    for team in league.teams:\n        wins = team.wins\n        scores = team.scores\n        total_points_scored = round(sum(scores), 2) / 100000\n        current_wins.append(wins + total_points_scored)\n\n    ###ONLY CONFIGURE THE VALUES ABOVE\n\n    teams = [int(x) for x in range(1, len(league.teams) + 1)]\n    weeks_played = (league_weeks) - ((len(home_teams)) / (len(teams) / 2))\n\n    last_playoff_wins = [0] * (league_weeks)\n    first_playoff_miss = [0] * (league_weeks)\n\n    import datetime\n\n    begin = datetime.datetime.now()\n    import random\n\n    league_size = len(teams)\n\n    games_per_week = int(league_size / 2)\n    weeks_to_play = int(league_weeks - weeks_played)\n    total_games = int(league_weeks * games_per_week)\n    games_left = int(weeks_to_play * games_per_week)\n\n    stats_teams = [0] * (league_size)\n\n    play_off_matrix = [[0 for x in range(teams_to_play_off)] for x in range(league_size)]\n\n    pad = int(games_left)\n\n    avg_wins = [0.0] * teams_to_play_off\n\n    for sims in progressbar.progressbar(range(1, simulations + 1)):\n        # create random binary array representing a single season's results\n        val = [int(random.getrandbits(1)) for x in range(1, (games_left + 1))]\n\n        empty_teams = [0.0] * league_size\n\n        i = 0\n        # assign wins based on 1 or 0 to home or away team\n        for x in val:\n            if (val[i] == 1):\n                empty_teams[home_teams[i] - 1] = empty_teams[home_teams[i] - 1] + 1\n            else:\n                empty_teams[away_teams[i] - 1] = empty_teams[away_teams[i] - 1] + 1\n            i = i + 1\n\n        # add the current wins to the rest of season's results\n        empty_teams = [sum(x) for x in zip(empty_teams, current_wins)]\n\n        # sort the teams\n        sorted_teams = sorted(empty_teams)\n\n        last_playoff_wins[int(round(sorted_teams[(league_size - teams_to_play_off)], 0)) - 1] = last_playoff_wins[int(round(sorted_teams[(league_size - teams_to_play_off)],0)) - 1] + 1\n        first_playoff_miss[int(round(sorted_teams[league_size - (teams_to_play_off + 1)], 0)) - 1] = \\\n        first_playoff_miss[int(round(sorted_teams[league_size - (teams_to_play_off + 1)], 0)) - 1] + 1\n\n        # pick the teams making the playoffs\n        for x in range(1, teams_to_play_off + 1):\n            stats_teams[empty_teams.index(sorted_teams[league_size - x])] = stats_teams[empty_teams.index(\n                sorted_teams[league_size - x])] + 1\n            avg_wins[x - 1] = avg_wins[x - 1] + round(sorted_teams[league_size - x], 0)\n            play_off_matrix[empty_teams.index(sorted_teams[league_size - x])][x - 1] = \\\n            play_off_matrix[empty_teams.index(sorted_teams[league_size - x])][x - 1] + 1\n\n    projections = []\n\n    playSpots = []\n\n    for x in range(1, len(stats_teams) + 1):\n        vals = ''\n        for y in range(1, teams_to_play_off + 1):\n            vals = vals + '\\t' + str(round((play_off_matrix[x - 1][y - 1]) / simulations * 100.0, 2))\n\n            playSpots.append(round((play_off_matrix[x - 1][y - 1]) / simulations * 100.0, 2))\n\n        playProb = round((stats_teams[x - 1]) / simulations * 100.0, 2)\n        playSpots.insert(0, playProb)\n        # print(\"Vals: \", playSpots)\n        projections.append(playSpots)\n        playSpots = []\n        # print(team_names[x-1]+'\\t'+str(round((stats_teams[x-1])/simulations*100.0,2))+vals)\n    # print(f'Pre dataframe projections\\n{projections}')\n    # Convert projections to Pandas Dataframe\n    projections = pd.DataFrame(projections)\n\n    # Insert Team Names to DataFrame\n    projections.insert(loc=0, column='Team', value=team_names)\n    projections = projections.set_axis(['Team', 'Playoffs', '1st Seed', '2nd Seed', '3rd Seed', '4th Seed'], axis=1)\n    projections = projections.sort_values(by=['Playoffs', '1st Seed', '2nd Seed', '3rd Seed', '4th Seed'], ascending=False)\n    # projections[['1st Seed','2nd Seed','3rd Seed', '4th Seed']] = projections[['1st Seed','2nd Seed','3rd Seed', '4th Seed']].astype(str) + \"%\"\n    projections.index = np.arange(1, len(projections) + 1)\n\n    median = projections['Playoffs'].median()\n\n    # bold only the playoff teams\n    for index, row in projections.iterrows():\n        if row['Playoffs'] > median:\n            projections.loc[index, 'Team'] = '**' + str(row['Team']) + '**'\n            projections.loc[index, 'Playoffs'] = '**' + str(row['Playoffs']) + '%**'\n            projections.loc[index, '1st Seed'] = '**' + str(row['1st Seed']) + '%**'\n            projections.loc[index, '2nd Seed'] = '**' + str(row['2nd Seed']) + '%**'\n            projections.loc[index, '3rd Seed'] = '**' + str(row['3rd Seed']) + '%**'\n            projections.loc[index, '4th Seed'] = '**' + str(row['4th Seed']) + '%**'\n        else:\n            projections.loc[index, 'Playoffs'] = str(row['Playoffs']) + '%'\n            projections.loc[index, '1st Seed'] = str(row['1st Seed']) + '%'\n            projections.loc[index, '2nd Seed'] = str(row['2nd Seed']) + '%'\n            projections.loc[index, '3rd Seed'] = str(row['3rd Seed']) + '%'\n            projections.loc[index, '4th Seed'] = str(row['4th Seed']) + '%'\n\n    print('')\n\n    # print('Average # of wins for playoff spot')\n    # for x in range(1,teams_to_play_off+1):\n    #     print(str(x)+'\\t'+str(round((avg_wins[x-1])/simulations,2)))\n\n    delta = datetime.datetime.now() - begin\n\n    # print('')\n    # print('Histrogram of wins required for final playoff spot')\n    # for x in range(1,len(last_playoff_wins)+1):\n    #     print(str(x)+'\\t'+str(round((last_playoff_wins[x-1])/(simulations*1.0)*100,3))+'\\t'+str(round((first_playoff_miss[x-1])/(simulations*1.0)*100,3)))\n\n    print('\\n{0:,}'.format(simulations) + \" Simulations ran in \" + str(delta))\n    print('\\nProjections:\\n', projections)\n\n    return projections\n\n\ndef gen_ai_summary():\n    print(\"\\n\\tRetrieving and processing matchups...\")\n\n    # Retrieve all matchups for the given week\n    matchups = league.box_scores(week=week)\n\n    # Extract box score data\n    box_scores_data = []\n\n    for matchup in matchups:\n        matchup_data = {\n            \"home_team\": matchup.home_team.team_name,\n            \"home_score\": matchup.home_score,\n            \"home_projected\": matchup.home_projected,\n            \"away_team\": matchup.away_team.team_name,\n            \"away_score\": matchup.away_score,\n            \"away_projected\": matchup.away_projected,\n            \"home_players\": [\n                {\n                    \"player_name\": player.name,\n                    \"slot_position\": player.slot_position,\n                    \"position\": player.position,\n                    \"points\": player.points,\n                    \"projected_points\": player.projected_points\n                } for player in matchup.home_lineup\n            ],\n            \"away_players\": [\n                {\n                    \"player_name\": player.name,\n                    \"position\": player.position,\n                    \"slot_position\": player.slot_position,\n                    \"points\": player.points,\n                    \"projected_points\": player.projected_points\n                } for player in matchup.away_lineup\n            ]\n        }\n        box_scores_data.append(matchup_data)\n\n    # Convert to JSON format\n    box_scores_json = json.dumps(box_scores_data, indent=4)\n\n    print(\"\\n\\tGenerating summary with LLM...\")\n\n    # Sample JSON data (replace with your actual JSON data)\n    json_data = box_scores_json\n\n    # Setting up OpenAI model\n    llm = ChatOpenAI(model_name=\"gpt-4o-mini\", temperature=0, openai_api_key=api_key)\n\n    # Define the prompt template for generating a newspaper-like summary\n    prompt_template = PromptTemplate(\n        input_variables=[\"json_data\"],\n        template=\"\"\"\n        Write a newspaper-style summary of the fantasy football matchups based on the following JSON data:\n\n        {json_data}\n\n        The summary should include:\n        - The names of the teams\n        - The projected scores for each team\n        - Key players and their projected points\n        - Any notable points or highlights\n\n        Write in a formal, engaging newspaper tone.\n        \"\"\"\n    )\n\n    # Initialize the LLMChain with the Llama model and prompt template\n    llm_chain = RunnableSequence(\n        prompt_template | llm\n    )\n\n    # Generate the newspaper-like summary\n    result = llm_chain.invoke(input=box_scores_json)\n\n    # return the result\n    return result.content\n\n# Generate Power Rankings\nrankings = gen_power_rankings()\n\n# Generate Expected Standings\n\n\n# Generate Playoff Probability (if week 5 or later) and append to expected standings\nif week > 5:\n    playoff_prob = gen_playoff_prob()\n\n# Generate Luck Index\nprint('\\nGenerating Luck Index...')\nbar_luck_index = progressbar.ProgressBar(max_value=len(teams))\n\nseason_luck_index = []\nluck_index_value = 0\nfor i, team in enumerate(teams):\n    team_name = team.team_name\n    for luck_week in range(1, week+1):\n        luck_index_value += luck_index.get_weekly_luck_index(league, team, luck_week)\n\n    # append team's season long luck index to the list\n    season_luck_index.append([team, luck_index_value])\n\n    # reset luck index value\n    luck_index_value = 0\n\n    # Update the progress bar\n    bar_luck_index.update(i + 1)\n\n# convert season long luck index list to pandas dataframe\nseason_luck_index = pd.DataFrame(season_luck_index, columns=['Team','Luck Index'])\n\n# Generate AI Summary\nprint('\\n\\nGenerating AI Summary...')\nsummary = gen_ai_summary()\n\n# Print everything\nprint('\\nWriting to markdown file...')\n# open text file\nfilepath = f\"/Users/christiangeer/Fantasy_Sports/football/power_rankings/jtown-dynasty/content/blog/Week{week}{year}PowerRankings.md\"\nsys.stdout = open(filepath, \"w\")\n\n# for the markdown files in blog\nprint(\"---\")\nprint(\"title: Week\", str(week), year, \"Report\")\nprint(\"date: \",datetime.now().date())\nprint(f\"image: /images/{year}week{week}.jpeg\")\nprint(\"draft: true\")\nprint(\"---\")\n\nprint(\"<!-- excerpt -->\")\n\nprint(\"\\n# POWER RANKINGS\\n\")\n# Value un-informed\nprint(table(rankings, headers='keys', tablefmt='pipe', numalign='center')) # have to manually center all play % because its not a number\n\n# print(table(Value_Power_Rankings_print, headers='keys',tablefmt='pipe', numalign='center')) # have to manually center all play % and weekly change because not an int\n\nprint('\\n## Summary:\\n')\nprint(summary)\n\n# print(\"\\n# EXPECTED STANDINGS (as of week \", week, \")\")\n# league.printExpectedStandings(week)\n# print(table(projectedStandings_prnt, headers='keys', tablefmt='pipe', numalign='center'))\n\nif week >= 5:\n    print(f\"\\n## PLAYOFF PROBABILITIES (as of week {week}\")\n    print(table(playoff_prob, headers='keys', tablefmt='pipe', numalign='center'))\n\nprint(\"\\n## LUCK INDEX\")\nprint(table(season_luck_index, headers='keys', tablefmt='pipe', numalign='center'))\n\n# print(\"\\n WEEK \", week, \" ALL PLAY STANDINGS (SORT BY WINS)\")\n# print(table(allplay, headers='keys', tablefmt='github', numalign='decimal'))\n\n# print(\"\\n WEEK \", week, \" POWER SCORE (CALC W/ LEAGUE AVERAGE SCORE)\")\n# print(table(team_scores_prt, headers='keys', tablefmt='github', numalign='decimal'))\n\n# close text file\nsys.stdout.close()\n\nprint('\\nDone!\\n')\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 7a3f90978afb8aaba93ecbedeba65458e5f203c6)
+++ b/main.py	(date 1725653091000)
@@ -426,8 +426,8 @@
 
 # for the markdown files in blog
 print("---")
-print("title: Week", str(week), year, "Report")
-print("date: ",datetime.now().date())
+print(f"title: Week {week} {year} Report")
+print(f"date: {datetime.now().date()}")
 print(f"image: /images/{year}week{week}.jpeg")
 print("draft: true")
 print("---")
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"187ec636-716f-4623-8c9b-b50a2d7c0e3f\" name=\"Changes\" comment=\"\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/main.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/main.py\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"expected-standings\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n    <option name=\"ROOT_SYNC\" value=\"DONT_SYNC\" />\n    <option name=\"SWAP_SIDES_IN_COMPARE_BRANCHES\" value=\"true\" />\n  </component>\n  <component name=\"ProjectColorInfo\">{\n  &quot;associatedIndex&quot;: 6\n}</component>\n  <component name=\"ProjectId\" id=\"2lIiGQMmMNYHpxoityGbS15jBFK\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\"><![CDATA[{\n  \"keyToString\": {\n    \"Python.main.executor\": \"Run\",\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\n    \"git-widget-placeholder\": \"master\",\n    \"last_opened_file_path\": \"/Users/christiangeer/Fantasy_Sports/football/power_rankings/espn-api-v3\",\n    \"settings.editor.selected.configurable\": \"project.propVCSSupport.CommitDialog\"\n  }\n}]]></component>\n  <component name=\"RecentsManager\">\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/doritostats\" />\n    </key>\n  </component>\n  <component name=\"RunManager\">\n    <configuration name=\"main\" type=\"PythonConfigurationType\" factoryName=\"Python\" nameIsGenerated=\"true\">\n      <module name=\"espn-api-v3\" />\n      <option name=\"ENV_FILES\" value=\"\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/main.py\" />\n      <option name=\"PARAMETERS\" value=\"1\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n  </component>\n  <component name=\"SharedIndexes\">\n    <attachedChunks>\n      <set>\n        <option value=\"bundled-python-sdk-ce3d9afa04ac-ba05f1cad1b1-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-242.20224.347\" />\n      </set>\n    </attachedChunks>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"187ec636-716f-4623-8c9b-b50a2d7c0e3f\" name=\"Changes\" comment=\"\" />\n      <created>1724873895265</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1724873895265</updated>\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"Getting box score JSON data to feed to LLM\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1725384218644</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1725384218644</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"Set up LLM chain with prompt template\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1725469954851</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1725469954851</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"function to generate expected standings\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1725639060662</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1725639060663</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"4\" />\n    <servers />\n  </component>\n  <component name=\"UnknownFeatures\">\n    <option featureType=\"com.intellij.fileTypeFactory\" implementationName=\".env\" />\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <option name=\"CLEAR_INITIAL_COMMIT_MESSAGE\" value=\"true\" />\n    <MESSAGE value=\"Getting box score JSON data to feed to LLM\" />\n    <MESSAGE value=\"Set up LLM chain with prompt template\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 7a3f90978afb8aaba93ecbedeba65458e5f203c6)
+++ b/.idea/workspace.xml	(date 1725653091062)
@@ -5,7 +5,6 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="187ec636-716f-4623-8c9b-b50a2d7c0e3f" name="Changes" comment="">
-      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/main.py" beforeDir="false" afterPath="$PROJECT_DIR$/main.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
